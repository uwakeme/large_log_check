<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ—¥å¿—æŸ¥çœ‹å™¨</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--vscode-editor-background);
            color: var(--vscode-editor-foreground);
            padding: 10px;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        
        .toolbar {
            background-color: var(--vscode-editorWidget-background);
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 10px;
            display: flex;
            gap: 10px;
            align-items: flex-start;
            flex-wrap: wrap;
        }
        
        .file-info {
            font-size: 12px;
            color: var(--vscode-descriptionForeground);
            flex: 1;
            min-width: 200px;
        }
        
        .search-box {
            display: flex;
            gap: 5px;
            flex: 1;
            min-width: 100%;
            flex-wrap: wrap;
            align-items: center;
        }
        
        input[type="text"] {
            flex: 1;
            min-width: 200px;
            padding: 5px 10px;
            background-color: var(--vscode-input-background);
            color: var(--vscode-input-foreground);
            border: 1px solid var(--vscode-input-border);
            border-radius: 3px;
            font-size: 12px;
        }
        
        button {
            padding: 5px 12px;
            background-color: var(--vscode-button-background);
            color: var(--vscode-button-foreground);
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
            white-space: nowrap;
            transition: background-color 0.2s;
        }
        
        button:hover {
            background-color: var(--vscode-button-hoverBackground);
        }
        
        .log-container {
            flex: 1;
            overflow-y: auto;
            background-color: var(--vscode-editor-background);
            border: 1px solid var(--vscode-panel-border);
            border-radius: 5px;
            padding: 10px;
            font-family: 'Consolas', 'Courier New', monospace;
            font-size: 12px;
            line-height: 1.5;
        }
        
        .log-line {
            padding: 2px 0;
            border-bottom: 1px solid var(--vscode-panel-border);
            white-space: pre-wrap;
            word-break: break-all;
        }
        
        .log-line:hover {
            background-color: var(--vscode-list-hoverBackground);
        }
        
        .log-line-number {
            display: inline-block;
            width: 60px;
            color: var(--vscode-editorLineNumber-foreground);
            user-select: none;
            text-align: right;
            padding-right: 10px;
        }
        
        .log-line-content {
            display: inline;
        }
        
        .highlight {
            background-color: var(--vscode-editor-findMatchHighlightBackground);
            color: var(--vscode-editor-findMatchHighlightForeground);
        }
        
        .loading {
            text-align: center;
            padding: 20px;
            color: var(--vscode-descriptionForeground);
        }
        
        .stats {
            font-size: 11px;
            color: var(--vscode-descriptionForeground);
        }
        
        .filter-panel {
            background-color: var(--vscode-editorWidget-background);
            padding: 8px;
            border-radius: 5px;
            margin-bottom: 10px;
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        /* ç­›é€‰çŠ¶æ€æç¤ºé¢æ¿ */
        .filter-status-panel {
            background-color: var(--vscode-editorWidget-background);
            padding: 8px 12px;
            border-radius: 5px;
            margin-bottom: 10px;
            display: flex;
            gap: 10px;
            align-items: center;
            border-left: 3px solid var(--vscode-textLink-foreground);
            animation: slideIn 0.3s ease-out;
        }
        
        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        /* æ—¶é—´çº¿é¢æ¿æ ·å¼ */
        .timeline-panel {
            background-color: var(--vscode-editorWidget-background);
            border-radius: 5px;
            margin-bottom: 10px;
            overflow: hidden;
        }
        
        .timeline-header {
            padding: 8px 12px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            user-select: none;
            transition: background-color 0.2s;
        }
        
        .timeline-header:hover {
            background-color: var(--vscode-list-hoverBackground);
        }
        
        .timeline-content {
            padding: 10px;
            border-top: 1px solid var(--vscode-panel-border);
        }
        
        #timelineCanvas {
            width: 100%;
            height: 80px;
            cursor: pointer;
        }
        
        .checkbox-group {
            display: flex;
            gap: 15px;
            align-items: center;
        }
        
        .checkbox-group label {
            display: flex;
            align-items: center;
            gap: 5px;
            cursor: pointer;
            font-size: 12px;
        }
        
        .checkbox-group input[type="checkbox"] {
            cursor: pointer;
        }
        
        .log-line.error {
            border-left: 3px solid #f14c4c;
            padding-left: 5px;
        }
        
        .log-line.warn {
            border-left: 3px solid #cca700;
            padding-left: 5px;
        }
        
        .log-line.info {
            border-left: 3px solid #4fc1ff;
            padding-left: 5px;
        }
        
        .log-line.debug {
            border-left: 3px solid #b267e6;
            padding-left: 5px;
        }
        
        /* æŠ˜å æ—¥å¿—æ ·å¼ */
        .log-line.collapsed {
            background-color: rgba(139, 92, 246, 0.1);
            border-left: 3px solid #8b5cf6;
            cursor: pointer;
        }
        
        .log-line.collapsed:hover {
            background-color: rgba(139, 92, 246, 0.2);
        }
        
        .repeat-count {
            display: inline-block;
            background-color: #8b5cf6;
            color: white;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 11px;
            font-weight: bold;
            margin-left: 10px;
            cursor: pointer;
        }
        
        .log-line.highlight-target {
            background-color: rgba(255, 193, 7, 0.3);
            border-left: 3px solid #ffc107;
            animation: highlight-pulse 0.5s ease-in-out;
        }
        
        @keyframes highlight-pulse {
            0%, 100% { background-color: rgba(255, 193, 7, 0.3); }
            50% { background-color: rgba(255, 193, 7, 0.6); }
        }
        
        @keyframes fadeInOut {
            0% { opacity: 0; transform: translateY(-10px); }
            10% { opacity: 1; transform: translateY(0); }
            90% { opacity: 1; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(-10px); }
        }
        
        /* å³é”®èœå•æ ·å¼ */
        .context-menu {
            position: fixed;
            background-color: var(--vscode-menu-background);
            border: 1px solid var(--vscode-menu-border);
            border-radius: 3px;
            padding: 4px 0;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            z-index: 10000;
            min-width: 180px;
        }
        
        .context-menu-item {
            padding: 6px 16px;
            cursor: pointer;
            font-size: 13px;
            color: var(--vscode-menu-foreground);
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .context-menu-item:hover {
            background-color: var(--vscode-menu-selectionBackground);
            color: var(--vscode-menu-selectionForeground);
        }
        
        .context-menu-separator {
            height: 1px;
            background-color: var(--vscode-menu-separatorBackground);
            margin: 4px 0;
        }
        
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
        }
        
        .modal-content {
            background-color: var(--vscode-editor-background);
            margin: 5% auto;
            border: 1px solid var(--vscode-panel-border);
            border-radius: 5px;
            width: 80%;
            max-width: 900px;
            max-height: 85vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        .modal-header {
            padding: 15px 20px;
            border-bottom: 1px solid var(--vscode-panel-border);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
        }
        
        .modal-header h2 {
            margin: 0;
            font-size: 18px;
        }
        
        .modal-body {
            padding: 20px;
            overflow-y: auto;
            overflow-x: hidden;
            flex: 1;
        }
        
        .modal-close {
            color: var(--vscode-foreground);
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin-top: 15px;
        }
        
        .stats-card {
            background-color: var(--vscode-editorWidget-background);
            padding: 15px;
            border-radius: 5px;
            border: 1px solid var(--vscode-panel-border);
        }
        
        .stats-card h3 {
            font-size: 14px;
            margin-bottom: 5px;
            color: var(--vscode-descriptionForeground);
        }
        
        .stats-card .value {
            font-size: 24px;
            font-weight: bold;
            color: var(--vscode-foreground);
        }
        
        /* åˆ†é¡µæ ·å¼ */
        .pagination {
            background-color: var(--vscode-editorWidget-background);
            padding: 10px;
            border-radius: 5px;
            margin-top: 10px;
            display: flex;
            gap: 10px;
            align-items: center;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        .pagination button {
            min-width: 35px;
            padding: 5px 10px;
        }
        
        .pagination button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .pagination .page-info {
            font-size: 13px;
            color: var(--vscode-descriptionForeground);
            margin: 0 10px;
            font-weight: 500;
        }
        
        .pagination input[type="number"] {
            width: 60px;
            padding: 3px 5px;
            text-align: center;
        }
        
        .pagination select {
            padding: 6px 8px;
            background-color: var(--vscode-input-background);
            color: var(--vscode-input-foreground);
            border: 1px solid var(--vscode-input-border);
            border-radius: 3px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 600;
        }
        
        .pagination select option {
            background-color: var(--vscode-dropdown-background);
            color: var(--vscode-dropdown-foreground);
            padding: 5px;
        }
        
        /* å¢å¼ºé«˜äº®æ ·å¼ */
        .highlight {
            background-color: #fbbf24;
            color: #000;
            padding: 2px 4px;
            border-radius: 2px;
            font-weight: bold;
        }
        
        .highlight-error {
            background-color: #f14c4c;
            color: #fff;
            padding: 2px 4px;
            border-radius: 2px;
            font-weight: bold;
        }
        
        .highlight-warn {
            background-color: #cca700;
            color: #fff;
            padding: 2px 4px;
            border-radius: 2px;
            font-weight: bold;
        }
        
        .highlight-info {
            background-color: #4fc1ff;
            color: #000;
            padding: 2px 4px;
            border-radius: 2px;
            font-weight: bold;
        }
        
        .highlight-time {
            background-color: #b267e6;
            color: #fff;
            padding: 2px 4px;
            border-radius: 2px;
            font-weight: bold;
        }
        
        /* çº¿ç¨‹åé«˜äº® */
        .highlight-thread {
            background-color: #06b6d4;
            color: #fff;
            padding: 2px 4px;
            border-radius: 2px;
            font-weight: 500;
        }
        
        /* ç±»åé«˜äº® */
        .highlight-class {
            background-color: #10b981;
            color: #fff;
            padding: 2px 4px;
            border-radius: 2px;
            font-weight: 500;
        }
        
        /* æ–¹æ³•åé«˜äº® */
        .highlight-method {
            background-color: #f59e0b;
            color: #fff;
            padding: 2px 4px;
            border-radius: 2px;
            font-weight: 500;
        }
        
        /* é€šç”¨ select å’Œ option æ ·å¼ */
        select {
            background-color: var(--vscode-dropdown-background);
            color: var(--vscode-dropdown-foreground);
            border: 1px solid var(--vscode-dropdown-border);
            border-radius: 3px;
            cursor: pointer;
        }
        
        select option {
            background-color: var(--vscode-dropdown-background);
            color: var(--vscode-dropdown-foreground);
            padding: 5px;
        }
        
        /* æ³¨é‡Šæ ·å¼ */
        .comment-badge {
            display: inline-block;
            background-color: #10b981;
            color: #fff;
            font-size: 10px;
            padding: 2px 6px;
            border-radius: 3px;
            margin-left: 5px;
            cursor: pointer;
            user-select: none;
        }
        
        .comment-badge:hover {
            background-color: #059669;
        }
        
        .log-comment {
            display: block;
            background-color: rgba(16, 185, 129, 0.1);
            border-left: 3px solid #10b981;
            padding: 5px 10px;
            margin-top: 3px;
            font-size: 11px;
            font-style: italic;
            color: var(--vscode-descriptionForeground);
        }
        
        /* JSON/XML æ ‘çŠ¶ç»“æ„æ ·å¼ */
        .json-tree, .xml-tree {
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 12px;
            line-height: 1.6;
            margin: 5px 0;
            padding: 8px;
            background-color: rgba(107, 114, 128, 0.05);
            border-radius: 4px;
            border-left: 3px solid #8b5cf6;
        }
        
        .json-tree-item, .xml-tree-item {
            margin-left: 15px;
            position: relative;
        }
        
        .json-tree-toggle, .xml-tree-toggle {
            display: inline-block;
            width: 14px;
            height: 14px;
            cursor: pointer;
            user-select: none;
            margin-right: 4px;
            color: var(--vscode-textLink-foreground);
            font-weight: bold;
            vertical-align: middle;
        }
        
        .json-tree-toggle:hover, .xml-tree-toggle:hover {
            background-color: var(--vscode-list-hoverBackground);
            border-radius: 2px;
        }
        
        .json-key {
            color: #9cdcfe;
            font-weight: 500;
        }
        
        .json-string {
            color: #ce9178;
        }
        
        .json-number {
            color: #b5cea8;
        }
        
        .json-boolean {
            color: #569cd6;
            font-weight: bold;
        }
        
        .json-null {
            color: #808080;
            font-style: italic;
        }
        
        .xml-tag {
            color: #4ec9b0;
        }
        
        .xml-attr-name {
            color: #9cdcfe;
        }
        
        .xml-attr-value {
            color: #ce9178;
        }
        
        .json-tree-collapsed, .xml-tree-collapsed {
            display: none;
        }
        
        .json-expand-btn {
            display: inline-block;
            margin-left: 5px;
            padding: 2px 6px;
            font-size: 10px;
            background-color: #8b5cf6;
            color: white;
            border-radius: 3px;
            cursor: pointer;
            user-select: none;
        }
        
        .json-expand-btn:hover {
            background-color: #7c3aed;
        }
        
        /* è‡ªå®šä¹‰é«˜äº®è§„åˆ™æ ·å¼ */
        .custom-highlight {
            padding: 2px 4px;
            border-radius: 2px;
            font-weight: 500;
            position: relative;
        }
        
        /* ç­›é€‰å›¾æ ‡æ ·å¼ */
        .filter-icon {
            display: inline-block;
            margin-left: 4px;
            font-size: 11px;
            opacity: 0.6;
            cursor: pointer;
            padding: 1px 3px;
            border-radius: 2px;
            transition: all 0.2s ease;
            user-select: none;
        }
        
        .filter-icon:hover {
            opacity: 1;
            background-color: rgba(0, 0, 0, 0.2);
            transform: scale(1.2);
        }
        
        .filter-icon:active {
            transform: scale(0.9);
        }
        
        /* å¯ç‚¹å‡»çš„ç­›é€‰é¡¹æ ·å¼ */
        .clickable-filter {
            transition: opacity 0.2s, transform 0.1s;
        }
        
        .clickable-filter:hover {
            opacity: 0.85;
            transform: scale(1.05);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .clickable-filter:active {
            transform: scale(0.95);
        }
        
        .rule-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            background-color: var(--vscode-editorWidget-background);
            border-radius: 5px;
            margin-bottom: 10px;
            border-left: 3px solid var(--vscode-panel-border);
        }
        
        .rule-item:hover {
            background-color: var(--vscode-list-hoverBackground);
        }
        
        .color-picker-wrapper {
            position: relative;
            display: inline-block;
        }
        
        .color-display {
            width: 40px;
            height: 30px;
            border-radius: 3px;
            border: 2px solid var(--vscode-panel-border);
            cursor: pointer;
        }
        
        .color-display:hover {
            border-color: var(--vscode-textLink-foreground);
        }
        
        /* è‡ªå®šä¹‰ç¡®è®¤å¯¹è¯æ¡† */
        .confirm-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10001;
        }
        
        .confirm-dialog {
            background-color: var(--vscode-editorWidget-background);
            border: 1px solid var(--vscode-panel-border);
            border-radius: 5px;
            padding: 20px;
            min-width: 300px;
            max-width: 500px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }
        
        .confirm-title {
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 15px;
            color: var(--vscode-foreground);
        }
        
        .confirm-message {
            margin-bottom: 20px;
            color: var(--vscode-foreground);
            line-height: 1.5;
        }
        
        .confirm-buttons {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }
        
        .confirm-buttons button {
            padding: 8px 20px;
            font-size: 13px;
        }
        
        /* æ›´å¤šèœå•ä¸‹æ‹‰æ ·å¼ */
        .dropdown {
            position: relative;
            display: inline-block;
        }
        
        .dropdown-content {
            display: none;
            position: absolute;
            right: 0;
            background-color: var(--vscode-editorWidget-background);
            min-width: 140px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            border: 1px solid var(--vscode-panel-border);
            border-radius: 3px;
            z-index: 1000;
            margin-top: 2px;
        }
        
        .dropdown-content button {
            width: 100%;
            text-align: left;
            padding: 8px 12px;
            border: none;
            background: none;
            color: var(--vscode-foreground);
            cursor: pointer;
            font-size: 13px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .dropdown-content button:hover {
            background-color: var(--vscode-list-hoverBackground);
        }
        
        .dropdown.show .dropdown-content {
            display: block;
        }

    </style>
</head>
<body>
    <div class="toolbar">
        <div class="file-info">
            <div><strong>æ–‡ä»¶:</strong> <span id="fileName">æœªåŠ è½½</span></div>
            <div class="stats">
                <span><strong>å¤§å°:</strong> <span id="fileSize">0</span>MB</span>
                <span style="margin-left: 15px;"><strong>æ€»è¡Œæ•°:</strong> <span id="totalLines">0</span></span>
                <span style="margin-left: 15px;"><strong>å·²åŠ è½½:</strong> <span id="loadedLines">0</span></span>
            </div>
        </div>
        <div class="search-box">
            <input type="text" id="searchInput" placeholder="æœç´¢æ—¥å¿—å†…å®¹...">
            <label style="font-size: 12px; display: flex; align-items: center; gap: 5px;">
                <input type="checkbox" id="regexMode">
                <span>æ­£åˆ™</span>
            </label>
            <label style="font-size: 12px; display: flex; align-items: center; gap: 5px;">
                <input type="checkbox" id="reverseMode">
                <span>åå‘æœç´¢</span>
            </label>
            <button onclick="search()">ğŸ” æœç´¢</button>
            <button onclick="showAdvancedSearchModal()">ğŸ” é«˜çº§æœç´¢</button>
            <button onclick="showJumpDialog()">ğŸ¯ å®šä½</button>
            <button onclick="showBookmarksModal()">ğŸ“Œ ä¹¦ç­¾</button>
            <button onclick="showCommentsModal()">ğŸ“ æ³¨é‡Š</button>
            <button onclick="showCustomHighlightModal()">ğŸ¨ é«˜äº®è§„åˆ™</button>
            <div class="dropdown">
                <button onclick="toggleMoreMenu()">â‹¯ æ›´å¤š</button>
                <div class="dropdown-content" id="moreMenu">
                    <button onclick="showStats(); closeMoreMenu();">ğŸ“ˆ ç»Ÿè®¡</button>
                    <button onclick="exportLogs(); closeMoreMenu();">ğŸ’¾ å¯¼å‡º</button>
                    <button onclick="showDeleteModal(); closeMoreMenu();">ğŸ—‘ï¸ åˆ é™¤</button>
                </div>
            </div>
            <button onclick="refresh()">ğŸ”„ åˆ·æ–°</button>
        </div>
    </div>
    
    <div class="filter-panel">
        <span style="font-size: 12px; font-weight: bold;">æ—¥å¿—çº§åˆ«:</span>
        <div class="checkbox-group">
            <label style="font-weight: bold; color: var(--vscode-button-background);">
                <input type="checkbox" id="filterAll" checked onchange="toggleAll()">
                <span>âœ”ï¸ å…¨é€‰</span>
            </label>
            <span style="width: 1px; height: 20px; background-color: var(--vscode-panel-border); margin: 0 5px;"></span>
            <label>
                <input type="checkbox" id="filterError" checked onchange="applyFilter()">
                <span style="color: #f14c4c; font-weight: bold;">â– </span> ERROR
            </label>
            <label>
                <input type="checkbox" id="filterWarn" checked onchange="applyFilter()">
                <span style="color: #cca700; font-weight: bold;">â– </span> WARN
            </label>
            <label>
                <input type="checkbox" id="filterInfo" checked onchange="applyFilter()">
                <span style="color: #4fc1ff; font-weight: bold;">â– </span> INFO
            </label>
            <label>
                <input type="checkbox" id="filterDebug" checked onchange="applyFilter()">
                <span style="color: #b267e6; font-weight: bold;">â– </span> DEBUG
            </label>
            <label><input type="checkbox" id="filterOther" checked onchange="applyFilter()"> å…¶ä»–</label>
        </div>
        <span style="width: 1px; height: 20px; background-color: var(--vscode-panel-border); margin: 0 10px;"></span>
        <label style="font-size: 12px; display: flex; align-items: center; gap: 5px; cursor: pointer;">
            <input type="checkbox" id="collapseRepeated" onchange="toggleCollapseMode()">
            <span>ğŸ“ æŠ˜å é‡å¤æ—¥å¿—</span>
        </label>
        <label style="font-size: 12px; display: flex; align-items: center; gap: 5px; cursor: pointer;">
            <input type="checkbox" id="enableJsonParse" checked onchange="toggleJsonParse()">
            <span>ğŸŒ² è§£æJSON/XML</span>
        </label>
    </div>
    
    <!-- ç­›é€‰çŠ¶æ€æç¤º -->
    <div class="filter-status-panel" id="filterStatusPanel" style="display: none;">
        <span style="font-size: 12px; font-weight: bold;">ğŸ” æ­£åœ¨ç­›é€‰ï¼š</span>
        <span id="filterStatusText" style="font-size: 12px; color: var(--vscode-textLink-foreground); font-weight: 500;"></span>
        <button onclick="clearCustomFilter()" style="padding: 3px 10px; font-size: 11px; margin-left: 10px;">âŒ å–æ¶ˆç­›é€‰</button>
    </div>
    
    <!-- æ—¶é—´çº¿å¯¼èˆª -->
    <div class="timeline-panel" id="timelinePanel" style="display: none;">
        <div class="timeline-header" onclick="toggleTimeline()">
            <span style="font-weight: bold; font-size: 12px;">ğŸ“ˆ æ—¶é—´çº¿å¯¼èˆª</span>
            <span id="timelineToggleIcon" style="font-size: 12px;">â–¼</span>
        </div>
        <div class="timeline-content" id="timelineContent">
            <canvas id="timelineCanvas" width="100%" height="80"></canvas>
            <div id="timelineInfo" style="font-size: 11px; color: var(--vscode-descriptionForeground); margin-top: 5px; text-align: center;">
                <!-- æ—¶é—´èŒƒå›´ä¿¡æ¯ -->
            </div>
        </div>
    </div>
    
    <div class="log-container" id="logContainer">
        <div class="loading">ç­‰å¾…åŠ è½½æ—¥å¿—æ–‡ä»¶...</div>
    </div>
    
    <!-- åˆ†é¡µæ§ä»¶ -->
    <div class="pagination" id="pagination" style="display: none;">
        <button onclick="goToFirstPage()" id="firstPageBtn">â®ï¸ é¦–é¡µ</button>
        <button onclick="goToPrevPage()" id="prevPageBtn">â—€ï¸ ä¸Šä¸€é¡µ</button>
        <span class="page-info">
            ç¬¬ <input type="number" id="currentPageInput" min="1" value="1" onchange="goToPage(this.value)"> 
            / <span id="totalPages">1</span> é¡µ
        </span>
        <button onclick="goToNextPage()" id="nextPageBtn">ä¸‹ä¸€é¡µ â–¶ï¸</button>
        <button onclick="goToLastPage()" id="lastPageBtn">æœ«é¡µ â­ï¸</button>
        <span class="page-info" style="margin-left: 20px;">
            <span style="font-size: 14px; font-weight: 600;">æ¯é¡µæ˜¾ç¤ºï¼š</span>
            <select id="pageSizeSelect" onchange="changePageSize(this.value)">
                <option value="50">50</option>
                <option value="100" selected>100</option>
                <option value="200">200</option>
                <option value="500">500</option>
                <option value="1000">1000</option>
            </select>
            <span style="font-size: 14px; font-weight: 600;">è¡Œ</span>
        </span>
        <span class="page-info">
            å…± <span id="totalLinesInPage">0</span> è¡Œ
        </span>
    </div>
    
    <!-- ç»Ÿè®¡å¼¹çª— -->
    <div id="statsModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>æ—¥å¿—ç»Ÿè®¡ä¿¡æ¯</h2>
                <span class="modal-close" onclick="closeStatsModal()">&times;</span>
            </div>
            <div class="modal-body">
                <div class="stats-grid" id="statsGrid">
                    <!-- ç»Ÿè®¡ä¿¡æ¯å°†åŠ¨æ€ç”Ÿæˆ -->
                </div>
            </div>
        </div>
    </div>
    
    <!-- æŒ‰æ—¶é—´åˆ é™¤å¼¹çª— -->
    <div id="deleteByTimeModal" class="modal">
        <div class="modal-content">
            <span class="modal-close" onclick="closeDeleteByTimeModal()">&times;</span>
            <h2>â° æŒ‰æ—¶é—´åˆ é™¤æ—¥å¿—</h2>
            <div style="margin-top: 20px;">
                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 5px; font-weight: bold;">åˆ é™¤æ¨¡å¼ï¼š</label>
                    <select id="deleteTimeMode" style="width: 100%; padding: 8px; background-color: var(--vscode-input-background); color: var(--vscode-input-foreground); border: 1px solid var(--vscode-input-border); border-radius: 3px;">
                        <option value="before">åˆ é™¤æŒ‡å®šæ—¶é—´ä¹‹å‰çš„æ—¥å¿—</option>
                        <option value="after">åˆ é™¤æŒ‡å®šæ—¶é—´ä¹‹åçš„æ—¥å¿—</option>
                    </select>
                </div>
                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 5px; font-weight: bold;">æ—¶é—´ï¼ˆæ”¯æŒæ ¼å¼ï¼š2024-01-01 12:00:00 æˆ– 2024-01-01ï¼‰ï¼š</label>
                    <input type="text" id="deleteTimeInput" placeholder="ä¾‹å¦‚ï¼š2024-01-01 12:00:00" style="width: 100%; padding: 8px; background-color: var(--vscode-input-background); color: var(--vscode-input-foreground); border: 1px solid var(--vscode-input-border); border-radius: 3px;">
                </div>
                <div style="background-color: var(--vscode-editorWidget-background); padding: 10px; border-radius: 3px; margin-bottom: 15px; border-left: 3px solid #d97706;">
                    <strong>âš ï¸ è­¦å‘Šï¼š</strong>æ­¤æ“ä½œä¼šç›´æ¥ä¿®æ”¹åŸæ–‡ä»¶ï¼Œä¸å¯æ¢å¤ï¼è¯·åŠ¡å¿…å¤‡ä»½é‡è¦æ—¥å¿—ï¼
                </div>
                <div style="display: flex; gap: 10px; justify-content: flex-end;">
                    <button onclick="closeDeleteByTimeModal()">å–æ¶ˆ</button>
                    <button onclick="confirmDeleteByTime()">ç¡®è®¤åˆ é™¤</button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- åˆ é™¤æ–¹å¼é€‰æ‹©å¼¹çª— -->
    <div id="deleteModal" class="modal">
        <div class="modal-content" style="max-width: 400px;">
            <div class="modal-header">
                <h2>ğŸ—‘ï¸ åˆ é™¤æ—¥å¿—</h2>
                <span class="modal-close" onclick="closeDeleteModal()">&times;</span>
            </div>
            <div class="modal-body">
                <div style="display: grid; gap: 15px;">
                    <button onclick="selectDeleteByTime()" style="padding: 15px; display: flex; align-items: center; gap: 10px; font-size: 14px;">
                        <span style="font-size: 20px;">â°</span>
                        <div style="text-align: left;">
                            <div style="font-weight: bold;">æŒ‰æ—¶é—´åˆ é™¤</div>
                            <div style="font-size: 11px; opacity: 0.9; margin-top: 3px;">åˆ é™¤æŒ‡å®šæ—¶é—´ä¹‹å‰/ä¹‹åçš„æ—¥å¿—</div>
                        </div>
                    </button>
                    <button onclick="selectDeleteByLine()" style="padding: 15px; display: flex; align-items: center; gap: 10px; font-size: 14px;">
                        <span style="font-size: 20px;">ğŸ“Š</span>
                        <div style="text-align: left;">
                            <div style="font-weight: bold;">æŒ‰è¡Œæ•°åˆ é™¤</div>
                            <div style="font-size: 11px; opacity: 0.9; margin-top: 3px;">åˆ é™¤æŒ‡å®šè¡Œä¹‹å‰/ä¹‹åçš„æ—¥å¿—</div>
                        </div>
                    </button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- æŒ‰è¡Œæ•°åˆ é™¤å¼¹çª— -->
    <div id="deleteByLineModal" class="modal">
        <div class="modal-content">
            <span class="modal-close" onclick="closeDeleteByLineModal()">&times;</span>
            <h2>ğŸ“Š æŒ‰è¡Œæ•°åˆ é™¤æ—¥å¿—</h2>
            <div style="margin-top: 20px;">
                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 5px; font-weight: bold;">åˆ é™¤æ¨¡å¼ï¼š</label>
                    <select id="deleteLineMode" style="width: 100%; padding: 8px; background-color: var(--vscode-input-background); color: var(--vscode-input-foreground); border: 1px solid var(--vscode-input-border); border-radius: 3px;">
                        <option value="before">åˆ é™¤æŒ‡å®šè¡Œä¹‹å‰çš„æ—¥å¿—</option>
                        <option value="after">åˆ é™¤æŒ‡å®šè¡Œä¹‹åçš„æ—¥å¿—</option>
                    </select>
                </div>
                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 5px; font-weight: bold;">è¡Œå·ï¼ˆä»1å¼€å§‹ï¼‰ï¼š</label>
                    <input type="number" id="deleteLineInput" placeholder="ä¾‹å¦‚ï¼š1000" min="1" style="width: 100%; padding: 8px; background-color: var(--vscode-input-background); color: var(--vscode-input-foreground); border: 1px solid var(--vscode-input-border); border-radius: 3px;">
                </div>
                <div style="background-color: var(--vscode-editorWidget-background); padding: 10px; border-radius: 3px; margin-bottom: 15px; border-left: 3px solid #dc2626;">
                    <strong>âš ï¸ è­¦å‘Šï¼š</strong>æ­¤æ“ä½œä¼šç›´æ¥ä¿®æ”¹åŸæ–‡ä»¶ï¼Œä¸å¯æ¢å¤ï¼è¯·åŠ¡å¿…å¤‡ä»½é‡è¦æ—¥å¿—ï¼
                </div>
                <div style="display: flex; gap: 10px; justify-content: flex-end;">
                    <button onclick="closeDeleteByLineModal()">å–æ¶ˆ</button>
                    <button onclick="confirmDeleteByLine()">ç¡®è®¤åˆ é™¤</button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- å¿«é€Ÿå®šä½å¼¹çª— -->
    <div id="jumpModal" class="modal">
        <div class="modal-content" style="max-width: 500px;">
            <div class="modal-header">
                <h2>ğŸ¯ å¿«é€Ÿå®šä½</h2>
                <span class="modal-close" onclick="closeJumpModal()">&times;</span>
            </div>
            <div class="modal-body">
                <div style="margin-bottom: 20px;">
                    <label style="display: block; margin-bottom: 5px; font-weight: bold;">å®šä½æ–¹å¼ï¼š</label>
                    <select id="jumpMode" onchange="switchJumpMode()" style="width: 100%; padding: 8px; background-color: var(--vscode-input-background); color: var(--vscode-input-foreground); border: 1px solid var(--vscode-input-border); border-radius: 3px; font-size: 13px;">
                        <option value="line">ğŸ“ æŒ‰è¡Œå·å®šä½</option>
                        <option value="time">â° æŒ‰æ—¶é—´å®šä½</option>
                    </select>
                </div>
                <div id="jumpByLineSection">
                    <div style="margin-bottom: 15px;">
                        <label style="display: block; margin-bottom: 5px; font-weight: bold;">è¡Œå·ï¼ˆä»1å¼€å§‹ï¼‰ï¼š</label>
                        <input type="number" id="jumpLineInput" placeholder="ä¾‹å¦‚ï¼š1000" min="1" style="width: 100%; padding: 8px; background-color: var(--vscode-input-background); color: var(--vscode-input-foreground); border: 1px solid var(--vscode-input-border); border-radius: 3px;">
                    </div>
                </div>
                <div id="jumpByTimeSection" style="display: none;">
                    <div style="margin-bottom: 15px;">
                        <label style="display: block; margin-bottom: 5px; font-weight: bold;">æ—¶é—´ï¼ˆæ”¯æŒæ ¼å¼ï¼š2024-01-01 12:00:00 æˆ– 2024-01-01ï¼‰ï¼š</label>
                        <input type="text" id="jumpTimeInput" placeholder="ä¾‹å¦‚ï¼š2025-11-14 09:00:00" style="width: 100%; padding: 8px; background-color: var(--vscode-input-background); color: var(--vscode-input-foreground); border: 1px solid var(--vscode-input-border); border-radius: 3px;">
                    </div>
                </div>
                <div style="background-color: var(--vscode-editorWidget-background); padding: 10px; border-radius: 3px; margin-bottom: 15px; border-left: 3px solid #0e7490;">
                    <strong>ğŸ’¡ æç¤ºï¼š</strong>å®šä½åå°†è‡ªåŠ¨è·³è½¬åˆ°å¯¹åº”çš„é¡µé¢å¹¶é«˜äº®æ˜¾ç¤º
                </div>
                <div style="display: flex; gap: 10px; justify-content: flex-end;">
                    <button onclick="closeJumpModal()">å–æ¶ˆ</button>
                    <button onclick="confirmJump()">å®šä½</button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- ä¹¦ç­¾ç®¡ç†å¼¹çª— -->
    <div id="bookmarksModal" class="modal">
        <div class="modal-content" style="max-width: 700px;">
            <div class="modal-header">
                <h2>ğŸ“Œ ä¹¦ç­¾åˆ—è¡¨</h2>
                <span class="modal-close" onclick="closeBookmarksModal()">&times;</span>
            </div>
            <div class="modal-body">
                <div id="bookmarksList" style="max-height: 400px; overflow-y: auto;">
                    <!-- ä¹¦ç­¾å°†åŠ¨æ€ç”Ÿæˆ -->
                </div>
                <div style="margin-top: 15px; text-align: center; color: var(--vscode-descriptionForeground); font-size: 12px;">
                    ğŸ’¡ æç¤ºï¼šåŒå‡»æ—¥å¿—è¡Œå¯æ·»åŠ /ç§»é™¤ä¹¦ç­¾
                </div>
            </div>
        </div>
    </div>
    
    <!-- æ³¨é‡Šç®¡ç†å¼¹çª— -->
    <div id="commentsModal" class="modal">
        <div class="modal-content" style="max-width: 800px;">
            <div class="modal-header">
                <h2>ğŸ“ æ³¨é‡Šåˆ—è¡¨</h2>
                <span class="modal-close" onclick="closeCommentsModal()">&times;</span>
            </div>
            <div class="modal-body">
                <div id="commentsList" style="max-height: 400px; overflow-y: auto;">
                    <!-- æ³¨é‡Šå°†åŠ¨æ€ç”Ÿæˆ -->
                </div>
                <div style="margin-top: 15px; text-align: center; color: var(--vscode-descriptionForeground); font-size: 12px;">
                    ğŸ’¡ æç¤ºï¼šå³é”®ç‚¹å‡»æ—¥å¿—è¡Œå¯æ·»åŠ æ³¨é‡Š
                </div>
            </div>
        </div>
    </div>
    
    <!-- æ·»åŠ /ç¼–è¾‘æ³¨é‡Šå¼¹çª— -->
    <div id="commentInputModal" class="modal">
        <div class="modal-content" style="max-width: 600px;">
            <div class="modal-header">
                <h2 id="commentInputTitle">ğŸ“ æ·»åŠ æ³¨é‡Š</h2>
                <span class="modal-close" onclick="closeCommentInputModal()">&times;</span>
            </div>
            <div class="modal-body">
                <div style="margin-bottom: 15px;">
                    <div style="font-weight: bold; margin-bottom: 5px;">è¡Œå·ï¼š<span id="commentInputLineNumber"></span></div>
                    <div style="font-size: 12px; color: var(--vscode-descriptionForeground); font-family: 'Consolas', monospace; background-color: var(--vscode-editorWidget-background); padding: 8px; border-radius: 3px; margin-bottom: 10px; max-height: 60px; overflow-y: auto;" id="commentInputPreview"></div>
                </div>
                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 5px; font-weight: bold;">æ³¨é‡Šå†…å®¹ï¼š</label>
                    <textarea id="commentInputText" rows="4" style="width: 100%; padding: 8px; background-color: var(--vscode-input-background); color: var(--vscode-input-foreground); border: 1px solid var(--vscode-input-border); border-radius: 3px; font-family: inherit; resize: vertical;" placeholder="è¯·è¾“å…¥æ³¨é‡Šå†…å®¹..." onkeydown="if(event.ctrlKey && event.key === 'Enter') confirmCommentInput();"></textarea>
                    <div style="font-size: 11px; color: var(--vscode-descriptionForeground); margin-top: 5px;">ğŸ’¡ æç¤ºï¼šæŒ‰ Ctrl+Enter å¿«é€Ÿä¿å­˜</div>
                </div>
                <div style="display: flex; gap: 10px; justify-content: flex-end;">
                    <button onclick="closeCommentInputModal()">å–æ¶ˆ</button>
                    <button onclick="confirmCommentInput()">ç¡®å®š</button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- é«˜çº§æœç´¢å¼¹çª— -->
    <div id="advancedSearchModal" class="modal">
        <div class="modal-content" style="max-width: 600px;">
            <div class="modal-header">
                <h2>ğŸ” é«˜çº§æœç´¢</h2>
                <span class="modal-close" onclick="closeAdvancedSearchModal()">&times;</span>
            </div>
            <div class="modal-body">
                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 5px; font-weight: bold;">å…³é”®è¯ï¼š</label>
                    <input type="text" id="advSearchKeyword" placeholder="è¾“å…¥æœç´¢å…³é”®è¯" style="width: 100%; padding: 8px; background-color: var(--vscode-input-background); color: var(--vscode-input-foreground); border: 1px solid var(--vscode-input-border); border-radius: 3px;">
                </div>
                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 5px; font-weight: bold;">æ—¶é—´èŒƒå›´ï¼š</label>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                        <input type="text" id="advSearchStartTime" placeholder="å¼€å§‹æ—¶é—´ (2024-01-01 10:00:00)" style="padding: 8px; background-color: var(--vscode-input-background); color: var(--vscode-input-foreground); border: 1px solid var(--vscode-input-border); border-radius: 3px;">
                        <input type="text" id="advSearchEndTime" placeholder="ç»“æŸæ—¶é—´ (2024-01-01 18:00:00)" style="padding: 8px; background-color: var(--vscode-input-background); color: var(--vscode-input-foreground); border: 1px solid var(--vscode-input-border); border-radius: 3px;">
                    </div>
                </div>
                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 5px; font-weight: bold;">æ—¥å¿—çº§åˆ«ï¼š</label>
                    <div style="display: flex; gap: 15px; flex-wrap: wrap;">
                        <label><input type="checkbox" id="advSearchError" checked> <span style="color: #f14c4c;">â– </span> ERROR</label>
                        <label><input type="checkbox" id="advSearchWarn" checked> <span style="color: #cca700;">â– </span> WARN</label>
                        <label><input type="checkbox" id="advSearchInfo" checked> <span style="color: #4fc1ff;">â– </span> INFO</label>
                        <label><input type="checkbox" id="advSearchDebug" checked> <span style="color: #b267e6;">â– </span> DEBUG</label>
                        <label><input type="checkbox" id="advSearchOther" checked> å…¶ä»–</label>
                    </div>
                </div>
                <div style="background-color: var(--vscode-editorWidget-background); padding: 10px; border-radius: 3px; margin-bottom: 15px; border-left: 3px solid #0e7490;">
                    <strong>ğŸ’¡ æç¤ºï¼š</strong>å¯ä»¥å•ç‹¬ä½¿ç”¨å…³é”®è¯ã€æ—¶é—´èŒƒå›´æˆ–çº§åˆ«ï¼Œä¹Ÿå¯ä»¥ç»„åˆä½¿ç”¨
                </div>
                <div style="display: flex; gap: 10px; justify-content: flex-end;">
                    <button onclick="closeAdvancedSearchModal()">å–æ¶ˆ</button>
                    <button onclick="confirmAdvancedSearch()">æœç´¢</button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- è‡ªå®šä¹‰é«˜äº®è§„åˆ™å¼¹çª— -->
    <div id="customHighlightModal" class="modal">
        <div class="modal-content" style="max-width: 800px;">
            <div class="modal-header">
                <h2>ğŸ¨ è‡ªå®šä¹‰é«˜äº®è§„åˆ™</h2>
                <span class="modal-close" onclick="closeCustomHighlightModal()">&times;</span>
            </div>
            <div class="modal-body">
                <div style="margin-bottom: 20px;">
                    <button onclick="showAddRuleDialog()" style="width: 100%; padding: 12px; font-weight: bold;">â• æ·»åŠ æ–°è§„åˆ™</button>
                </div>
                <div id="highlightRulesList" style="max-height: 500px; overflow-y: auto;">
                    <!-- è§„åˆ™åˆ—è¡¨å°†åŠ¨æ€ç”Ÿæˆ -->
                </div>
            </div>
        </div>
    </div>
    
    <!-- æ·»åŠ /ç¼–è¾‘é«˜äº®è§„åˆ™å¼¹çª— -->
    <div id="addRuleModal" class="modal">
        <div class="modal-content" style="max-width: 600px;">
            <div class="modal-header">
                <h2 id="ruleModalTitle">â• æ·»åŠ é«˜äº®è§„åˆ™</h2>
                <span class="modal-close" onclick="closeAddRuleModal()">&times;</span>
            </div>
            <div class="modal-body">
                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 5px; font-weight: bold;">è§„åˆ™åç§°ï¼š</label>
                    <input type="text" id="ruleName" placeholder="ä¾‹å¦‚ï¼šAPIè°ƒç”¨ã€é”™è¯¯ä»£ç " style="width: 100%; padding: 8px; background-color: var(--vscode-input-background); color: var(--vscode-input-foreground); border: 1px solid var(--vscode-input-border); border-radius: 3px;">
                </div>
                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 5px; font-weight: bold;">åŒ¹é…æ¨¡å¼ï¼š</label>
                    <select id="ruleType" style="width: 100%; padding: 8px; background-color: var(--vscode-input-background); color: var(--vscode-input-foreground); border: 1px solid var(--vscode-input-border); border-radius: 3px;">
                        <option value="text">æ–‡æœ¬åŒ¹é…</option>
                        <option value="regex">æ­£åˆ™è¡¨è¾¾å¼</option>
                    </select>
                </div>
                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 5px; font-weight: bold;">åŒ¹é…å†…å®¹ï¼š</label>
                    <input type="text" id="rulePattern" placeholder="ä¾‹å¦‚ï¼šAPIæˆ– \\bERROR\\b" style="width: 100%; padding: 8px; background-color: var(--vscode-input-background); color: var(--vscode-input-foreground); border: 1px solid var(--vscode-input-border); border-radius: 3px;">
                </div>
                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 5px; font-weight: bold;">é«˜äº®é¢œè‰²ï¼š</label>
                    <div style="display: flex; gap: 10px; align-items: center;">
                        <input type="color" id="ruleBgColor" value="#10b981" style="width: 80px; height: 40px; border: none; cursor: pointer;">
                        <input type="color" id="ruleTextColor" value="#ffffff" style="width: 80px; height: 40px; border: none; cursor: pointer;">
                        <div style="flex: 1;">
                            <div style="font-size: 11px; color: var(--vscode-descriptionForeground);">é¢„è§ˆï¼š</div>
                            <div id="colorPreview" style="display: inline-block; padding: 4px 8px; border-radius: 3px; background-color: #10b981; color: #ffffff; font-weight: 500;">ç¤ºä¾‹æ–‡æœ¬</div>
                        </div>
                    </div>
                </div>
                <div style="margin-bottom: 15px;">
                    <label style="display: flex; align-items: center; gap: 5px; cursor: pointer;">
                        <input type="checkbox" id="ruleEnabled" checked>
                        <span>å¯ç”¨æ­¤è§„åˆ™</span>
                    </label>
                </div>
                <div style="background-color: var(--vscode-editorWidget-background); padding: 10px; border-radius: 3px; margin-bottom: 15px; border-left: 3px solid #8b5cf6;">
                    <strong>ğŸ’¡ æç¤ºï¼š</strong>æ­£åˆ™è¡¨è¾¾å¼ç¤ºä¾‹ï¼š<code>\\b\w+:\\d+\\b</code> åŒ¹é…æ–¹æ³•å:lineå·
                </div>
                <div style="display: flex; gap: 10px; justify-content: flex-end;">
                    <button onclick="closeAddRuleModal()">å–æ¶ˆ</button>
                    <button onclick="saveHighlightRule()">ä¿å­˜</button>
                </div>
            </div>
        </div>
    </div>


    <script>
        const vscode = acquireVsCodeApi();
        let allLines = [];
        let currentSearchKeyword = '';
        let originalLines = []; // ä¿å­˜åŸå§‹æ•°æ®ç”¨äºè¿‡æ»¤
        let isFiltering = false; // æ ‡è®°æ˜¯å¦åœ¨è¿‡æ»¤æ¨¡å¼ä¸‹
        let bookmarks = new Set(); // ä¹¦ç­¾é›†åˆï¼Œå­˜å‚¨è¡Œå·
        let comments = new Map(); // æ³¨é‡Šé›†åˆï¼Œkeyä¸ºè¡Œå·ï¼Œvalueä¸ºæ³¨é‡Šå†…å®¹
        let timelineData = null; // æ—¶é—´çº¿æ•°æ®
        let isTimelineExpanded = true; // æ—¶é—´çº¿æ˜¯å¦å±•å¼€
        let isCollapseMode = false; // æ˜¯å¦å¼€å¯æŠ˜å æ¨¡å¼
        let expandedGroups = new Set(); // å·²å±•å¼€çš„æŠ˜å ç»„
        let pageRanges = new Map(); // è®°å½•æ¯é¡µå®é™…åŠ è½½çš„è¡ŒèŒƒå›´ Map<pageNumber, {start, end}>
        let isCalculatingPages = false; // æ˜¯å¦æ­£åœ¨è®¡ç®—é¡µé¢èŒƒå›´
        let calculationProgress = 0; // è®¡ç®—è¿›åº¦ï¼ˆ0-100ï¼‰
        
        // ç­›é€‰çŠ¶æ€ç®¡ç†
        let currentFilterType = null; // å½“å‰ç­›é€‰ç±»å‹: 'thread', 'class', 'method', null
        let currentFilterValue = null; // å½“å‰ç­›é€‰å€¼
        let savedPageBeforeFilter = 1; // ç­›é€‰å‰çš„é¡µç 
        let savedFirstLineBeforeFilter = null; // ç­›é€‰å‰å½“å‰é¡µç¬¬ä¸€è¡Œçš„è¡Œå·
        
        /**
         * ç»Ÿä¸€å¤„ç†æ•°æ®å˜æ›´åçš„é¡µé¢è®¡ç®—
         * åœ¨ä»¥ä¸‹æƒ…å†µä¸‹è°ƒç”¨ï¼š
         * 1. æ–‡ä»¶åŠ è½½/åˆ·æ–°
         * 2. æœç´¢/ç­›é€‰æ“ä½œ
         * 3. åˆ‡æ¢æŠ˜å æ¨¡å¼
         * 4. åŠ è½½æ›´å¤šæ•°æ®
         */
        function handleDataChange(options = {}) {
            const {
                resetPage = true,           // æ˜¯å¦é‡ç½®åˆ°ç¬¬ä¸€é¡µ
                clearPageRanges = true,     // æ˜¯å¦æ¸…ç©ºé¡µé¢èŒƒå›´è®°å½•
                triggerAsyncCalc = true     // æ˜¯å¦è§¦å‘å¼‚æ­¥è®¡ç®—
            } = options;
            
            console.log('ğŸ”„ æ•°æ®å˜æ›´å¤„ç†:', { resetPage, clearPageRanges, triggerAsyncCalc, isCollapseMode, dataLength: allLines.length });
            
            // é‡ç½®é¡µç 
            if (resetPage) {
                currentPage = 1;
            }
            
            // æ¸…ç©ºé¡µé¢èŒƒå›´è®°å½•
            if (clearPageRanges) {
                pageRanges.clear();
            }
            
            // æ¸…ç©ºè®¡ç®—çŠ¶æ€
            isCalculatingPages = false;
            calculationProgress = 0;
            
            // æ›´æ–°åˆ†é¡µå™¨å’Œæ¸²æŸ“
            updatePagination();
            renderLines();
            
            // å¦‚æœå¼€å¯äº†æŠ˜å æ¨¡å¼ä¸”æœ‰æ•°æ®ï¼Œè§¦å‘å¼‚æ­¥è®¡ç®—
            if (triggerAsyncCalc && isCollapseMode && allLines.length > 0) {
                console.log('ğŸ“Š è§¦å‘å¼‚æ­¥é¡µé¢è®¡ç®—...');
                calculateAllPagesAsync();
            }
        }
        
        // åˆ†é¡µå‚æ•°
        let currentPage = 1;
        let pageSize = 100;
        let totalPages = 1;
        
        // æ•°æ®åŠ è½½çŠ¶æ€
        let totalLinesInFile = 0;
        let allDataLoaded = false;
        
        window.addEventListener('message', event => {
            const message = event.data;
            
            switch (message.command) {
                case 'fileLoaded':
                    handleFileLoaded(message.data);
                    break;
                case 'moreLines':
                    handleMoreLines(message.data);
                    break;
                case 'searchResults':
                    handleSearchResults(message.data);
                    break;
                case 'filterResults':
                    handleFilterResults(message.data);
                    break;
                case 'statisticsResults':
                    handleStatisticsResults(message.data);
                    break;
                case 'jumpToTimeResult':
                    handleJumpToTimeResult(message.data);
                    break;
                case 'jumpToLineInFullLogResult':
                    handleJumpToLineInFullLogResult(message.data);
                    break;
            }
        });
        
        function handleFileLoaded(data) {
            document.getElementById('fileName').textContent = data.fileName;
            document.getElementById('fileSize').textContent = data.fileSize;
            document.getElementById('totalLines').textContent = data.totalLines;
            
            totalLinesInFile = data.totalLines;
            allDataLoaded = data.allLoaded || false;
            isFiltering = false; // é‡ç½®è¿‡æ»¤çŠ¶æ€
            currentSearchKeyword = ''; // é‡ç½®æœç´¢å…³é”®è¯
            
            // æ¸…é™¤ç­›é€‰çŠ¶æ€
            currentFilterType = null;
            currentFilterValue = null;
            hideFilterStatus();
            
            allLines = data.lines;
            originalLines = [...data.lines];
            
            // ç»Ÿä¸€å¤„ç†æ•°æ®å˜æ›´
            handleDataChange();
            
            // ç”Ÿæˆæ—¶é—´çº¿
            generateTimeline();
            
            // å¦‚æœæ•°æ®æœªå…¨éƒ¨åŠ è½½ï¼Œæ˜¾ç¤ºæç¤º
            if (!allDataLoaded && allLines.length < totalLinesInFile) {
                showLoadMoreHint();
            }
        }
        
        function handleMoreLines(data) {
            allLines = allLines.concat(data.lines);
            originalLines = originalLines.concat(data.lines);
            
            // æ£€æŸ¥æ˜¯å¦å·²åŠ è½½å…¨éƒ¨æ•°æ®
            if (allLines.length >= totalLinesInFile) {
                allDataLoaded = true;
            }
            
            // åŠ è½½æ›´å¤šæ•°æ®æ—¶ä¸é‡ç½®é¡µç ï¼Œä½†éœ€è¦é‡æ–°è®¡ç®—
            handleDataChange({
                resetPage: false,           // ä¸é‡ç½®é¡µç 
                clearPageRanges: false,     // ä¸æ¸…ç©ºå·²è®¡ç®—çš„é¡µé¢
                triggerAsyncCalc: true      // è§¦å‘å¼‚æ­¥è®¡ç®—æ–°é¡µé¢
            });
        }
        
        function handleSearchResults(data) {
            currentSearchKeyword = data.keyword;
            allLines = data.results;
            
            // ç»Ÿä¸€å¤„ç†æ•°æ®å˜æ›´
            handleDataChange();
        }
        
        function handleFilterResults(data) {
            console.log('ğŸ“¥ æ”¶åˆ°è¿‡æ»¤ç»“æœ:', data.results.length, 'æ¡');
            allLines = data.results;
            isFiltering = true; // è®¾ç½®ä¸ºè¿‡æ»¤æ¨¡å¼
            
            // ç»Ÿä¸€å¤„ç†æ•°æ®å˜æ›´
            handleDataChange();
            
            // å¦‚æœè¿‡æ»¤ç»“æœä¸ºç©ºï¼Œç»™å‡ºå‹å¥½æç¤º
            if (data.results.length === 0) {
                const levelText = data.levels.join('ã€');
                vscode.postMessage({
                    command: 'showMessage',
                    type: 'warning',
                    message: `æœªæ‰¾åˆ° ${levelText} çº§åˆ«çš„æ—¥å¿—ï¼Œè¯·å°è¯•å…¶ä»–çº§åˆ«æˆ–æŸ¥çœ‹ç»Ÿè®¡ä¿¡æ¯`
                });
            }
        }
        
        function handleStatisticsResults(data) {
            showStatsModal(data);
        }
        
        function handleJumpToLineInFullLogResult(data) {
            // é‡æ–°åŠ è½½å®Œæ•´æ—¥å¿—æ•°æ®
            document.getElementById('fileName').textContent = data.fileName;
            document.getElementById('fileSize').textContent = data.fileSize;
            document.getElementById('totalLines').textContent = data.totalLines;
            
            totalLinesInFile = data.totalLines;
            allDataLoaded = data.allLoaded || false;
            isFiltering = false; // é‡ç½®è¿‡æ»¤çŠ¶æ€
            currentSearchKeyword = ''; // é‡ç½®æœç´¢å…³é”®è¯
            
            allLines = data.lines;
            originalLines = [...data.lines];
            
            // ç»Ÿä¸€å¤„ç†æ•°æ®å˜æ›´ï¼ˆä½†ä¸é‡ç½®é¡µç ï¼Œå› ä¸ºè¦è·³è½¬åˆ°ç›®æ ‡è¡Œï¼‰
            handleDataChange({
                resetPage: false  // ä¸é‡ç½®é¡µç ï¼Œç”± jumpToLine å†³å®š
            });
            
            // è·³è½¬åˆ°ç›®æ ‡è¡Œ
            jumpToLine(data.targetLineNumber);
            
            // ç”Ÿæˆæ—¶é—´çº¿
            generateTimeline();
            
            // æ˜¾ç¤ºæˆåŠŸæç¤º
            showToast('âœ… å·²è·³è½¬åˆ°å®Œæ•´æ—¥å¿—');
        }
        
        function renderLines() {
            const container = document.getElementById('logContainer');
            container.innerHTML = '';
            
            console.log('ğŸ¨ æ¸²æŸ“æ—¥å¿— - å½“å‰ allLines æ•°é‡:', allLines.length, 'ï¼ŒæŠ˜å æ¨¡å¼:', isCollapseMode);
            
            if (allLines.length === 0) {
                container.innerHTML = '<div class="loading">æ²¡æœ‰æ—¥å¿—æ•°æ®</div>';
                document.getElementById('pagination').style.display = 'none';
                document.getElementById('loadedLines').textContent = '0';
                console.log('âš ï¸ æ¸²æŸ“ç»“æœ: æ˜¾ç¤º"æ²¡æœ‰æ—¥å¿—æ•°æ®"');
                return;
            }
            
            // è®¡ç®—åˆ†é¡µ
            let startIndex, endIndex;
            
            if (isCollapseMode && pageRanges.has(currentPage)) {
                // æŠ˜å æ¨¡å¼ä¸”å·²è®°å½•è¿‡è¯¥é¡µèŒƒå›´ï¼Œç›´æ¥ä½¿ç”¨
                const range = pageRanges.get(currentPage);
                startIndex = range.start;
                endIndex = range.end;
                console.log(`ğŸ“– ä½¿ç”¨å·²è®°å½•çš„ç¬¬ ${currentPage} é¡µèŒƒå›´: ${startIndex}-${endIndex}`);
            } else if (isCollapseMode && currentPage > 1 && pageRanges.has(currentPage - 1)) {
                // æŠ˜å æ¨¡å¼ä¸”æ˜¯æ–°é¡µé¢ï¼Œä»ä¸Šä¸€é¡µçš„ç»“æŸä½ç½®å¼€å§‹
                const prevRange = pageRanges.get(currentPage - 1);
                startIndex = prevRange.end;
                endIndex = Math.min(startIndex + pageSize, allLines.length);
                console.log(`ğŸ“– ä»ä¸Šä¸€é¡µç»“æŸä½ç½® ${startIndex} å¼€å§‹åŠ è½½ç¬¬ ${currentPage} é¡µ`);
            } else {
                // éæŠ˜å æ¨¡å¼æˆ–ç¬¬ä¸€é¡µï¼Œä½¿ç”¨æ ‡å‡†è®¡ç®—
                startIndex = (currentPage - 1) * pageSize;
                endIndex = Math.min(startIndex + pageSize, allLines.length);
                console.log(`ğŸ“– æ ‡å‡†åˆ†é¡µè®¡ç®—ç¬¬ ${currentPage} é¡µ: ${startIndex}-${endIndex}`);
            }
            
            // å¦‚æœå¼€å¯æŠ˜å æ¨¡å¼ï¼ŒåŠ¨æ€è°ƒæ•´åŠ è½½æ•°é‡ä»¥å¡«æ»¡é¡µé¢
            if (isCollapseMode) {
                const targetDisplayLines = pageSize; // ç›®æ ‡æ˜¾ç¤ºæ•°é‡ï¼ˆæŠ˜å åï¼‰
                let displayCount = 0;
                let tempEndIndex = endIndex;
                let attempts = 0;
                const maxAttempts = 5; // æœ€å¤šå°è¯•5æ¬¡ï¼Œé¿å…æ­»å¾ªç¯
                const maxLoadLines = pageSize * 50; // æœ€å¤šåŠ è½½50å€ï¼Œé¿å…è¿‡åº¦åŠ è½½
                
                // å°è¯•åŠ è½½æ›´å¤šæ•°æ®ç›´åˆ°è¾¾åˆ°ç›®æ ‡æ˜¾ç¤ºæ•°é‡
                while (displayCount < targetDisplayLines && tempEndIndex < allLines.length && attempts < maxAttempts) {
                    // é™åˆ¶æœ€å¤§åŠ è½½èŒƒå›´
                    if (tempEndIndex - startIndex > maxLoadLines) {
                        console.log(`âš ï¸ å·²è¾¾åˆ°æœ€å¤§åŠ è½½é™åˆ¶ ${maxLoadLines} è¡Œï¼Œåœæ­¢åŠ è½½`);
                        break;
                    }
                    
                    const testLines = allLines.slice(startIndex, tempEndIndex);
                    const collapsed = collapseRepeatedLines(testLines, startIndex);
                    displayCount = collapsed.length;
                    
                    console.log(`ğŸ”„ å°è¯• ${attempts + 1}ï¼šåŠ è½½ ${tempEndIndex - startIndex} è¡Œï¼ŒæŠ˜å åå¾—åˆ° ${displayCount} æ¡ï¼Œç›®æ ‡ ${targetDisplayLines} æ¡`);
                    
                    if (displayCount < targetDisplayLines) {
                        // éœ€è¦åŠ è½½æ›´å¤šï¼Œä½†è¦é™åˆ¶å¢é‡
                        const needed = targetDisplayLines - displayCount;
                        const ratio = displayCount > 0 ? (tempEndIndex - startIndex) / displayCount : 1;
                        
                        // è®¡ç®—å¢é‡ï¼Œä½†ä¸è¦è¶…è¿‡å‰©ä½™éœ€æ±‚çš„5å€
                        let increment = Math.ceil(needed * ratio * 0.5); // åªå¢åŠ 50%ï¼Œé¿å…è¿‡åº¦
                        increment = Math.max(increment, 50); // è‡³å°‘å¢åŠ 50æ¡
                        increment = Math.min(increment, pageSize * 2); // æœ€å¤šå¢åŠ 2å€pageSize
                        
                        tempEndIndex = Math.min(tempEndIndex + increment, allLines.length);
                        attempts++;
                    } else {
                        break;
                    }
                }
                
                endIndex = tempEndIndex;
                console.log(`ğŸ“ æŠ˜å æ¨¡å¼ï¼šæœ€ç»ˆåŠ è½½èŒƒå›´ ${startIndex}-${endIndex}ï¼ˆ${endIndex - startIndex} è¡Œï¼‰ï¼ŒæŠ˜å åæ˜¾ç¤º ${displayCount} æ¡`);
                
                // è®°å½•è¯¥é¡µçš„å®é™…èŒƒå›´
                pageRanges.set(currentPage, { start: startIndex, end: endIndex });
            } else if (isCollapseMode) {
                // æŠ˜å æ¨¡å¼ä½†æ²¡æœ‰æ™ºèƒ½åŠ è½½ï¼Œä¹Ÿè¦è®°å½•èŒƒå›´
                pageRanges.set(currentPage, { start: startIndex, end: endIndex });
            }
            
            let pageLines = allLines.slice(startIndex, endIndex);
            
            // å¦‚æœå¼€å¯æŠ˜å æ¨¡å¼ï¼Œè¿›è¡ŒæŠ˜å å¤„ç†
            if (isCollapseMode) {
                pageLines = collapseRepeatedLines(pageLines, startIndex);
            }
            
            pageLines.forEach((item, index) => {
                // item å¯èƒ½æ˜¯å•æ¡æ—¥å¿—æˆ–æŠ˜å ç»„
                if (item.isCollapsed) {
                    // æ¸²æŸ“æŠ˜å ç»„
                    renderCollapsedGroup(container, item);
                } else {
                    // æ¸²æŸ“å•æ¡æ—¥å¿—
                    const line = item;
                    renderSingleLine(container, line, startIndex, index);
                }
            });
            
            document.getElementById('loadedLines').textContent = allLines.length;
            document.getElementById('pagination').style.display = 'flex';
            
            console.log(`âœ… æ¸²æŸ“å®Œæˆï¼å®é™…æ˜¾ç¤º ${pageLines.length} æ¡ï¼ˆåŸå§‹ ${endIndex - startIndex} è¡Œï¼‰`);
        }
        
        // è®¡ç®—æŒ‡å®šé¡µé¢çš„èŒƒå›´ï¼ˆä¸æ¸²æŸ“ï¼Œåªè®¡ç®—ï¼‰
        function calculatePageRange(pageNum) {
            console.log(`ğŸ§® è®¡ç®—ç¬¬ ${pageNum} é¡µèŒƒå›´...`);
            
            if (allLines.length === 0) {
                pageRanges.set(pageNum, { start: 0, end: 0 });
                return;
            }
            
            // è®¡ç®—åˆ†é¡µ
            let startIndex, endIndex;
            
            if (pageNum === 1) {
                startIndex = 0;
                endIndex = Math.min(pageSize, allLines.length);
            } else if (pageRanges.has(pageNum - 1)) {
                const prevRange = pageRanges.get(pageNum - 1);
                startIndex = prevRange.end;
                endIndex = Math.min(startIndex + pageSize, allLines.length);
            } else {
                console.log(`âš ï¸ æ— æ³•è®¡ç®—ç¬¬ ${pageNum} é¡µï¼Œç¼ºå°‘ä¸Šä¸€é¡µæ•°æ®`);
                return;
            }
            
            // å¦‚æœå¼€å¯æŠ˜å æ¨¡å¼ï¼ŒåŠ¨æ€è°ƒæ•´åŠ è½½æ•°é‡ä»¥å¡«æ»¡é¡µé¢
            if (isCollapseMode) {
                const targetDisplayLines = pageSize;
                let displayCount = 0;
                let tempEndIndex = endIndex;
                let attempts = 0;
                const maxAttempts = 5;
                const maxLoadLines = pageSize * 50;
                
                while (displayCount < targetDisplayLines && tempEndIndex < allLines.length && attempts < maxAttempts) {
                    if (tempEndIndex - startIndex > maxLoadLines) {
                        break;
                    }
                    
                    const testLines = allLines.slice(startIndex, tempEndIndex);
                    const collapsed = collapseRepeatedLines(testLines, startIndex);
                    displayCount = collapsed.length;
                    
                    if (displayCount < targetDisplayLines) {
                        const needed = targetDisplayLines - displayCount;
                        const ratio = displayCount > 0 ? (tempEndIndex - startIndex) / displayCount : 1;
                        let increment = Math.ceil(needed * ratio * 0.5);
                        increment = Math.max(increment, 50);
                        increment = Math.min(increment, pageSize * 2);
                        tempEndIndex = Math.min(tempEndIndex + increment, allLines.length);
                        attempts++;
                    } else {
                        break;
                    }
                }
                
                endIndex = tempEndIndex;
            }
            
            pageRanges.set(pageNum, { start: startIndex, end: endIndex });
            console.log(`âœ… ç¬¬ ${pageNum} é¡µèŒƒå›´: ${startIndex}-${endIndex}`);
        }
        
        // å¼‚æ­¥è®¡ç®—æ‰€æœ‰é¡µé¢èŒƒå›´
        async function calculateAllPagesAsync() {
            if (allLines.length === 0 || !isCollapseMode) {
                return;
            }
            
            isCalculatingPages = true;
            calculationProgress = 0;
            pageRanges.clear();
            
            console.log('ğŸ“Š å¼€å§‹å¼‚æ­¥è®¡ç®—æ‰€æœ‰é¡µé¢èŒƒå›´...');
            updatePagination(); // æ›´æ–°UIæ˜¾ç¤º"è®¡ç®—ä¸­..."
            
            let pageNum = 1;
            let lastEndIndex = 0;
            
            // ä½¿ç”¨åˆ†æ‰¹å¤„ç†ï¼Œæ¯æ¬¡è®¡ç®—5é¡µï¼Œç„¶åè®©å‡ºCPUæ—¶é—´
            while (lastEndIndex < allLines.length && isCollapseMode) { // æ·»åŠ æ£€æŸ¥ï¼šå¦‚æœå–æ¶ˆæŠ˜å ï¼Œåœæ­¢è®¡ç®—
                // æ‰¹é‡è®¡ç®—5é¡µ
                for (let i = 0; i < 5 && lastEndIndex < allLines.length; i++) {
                    if (!isCollapseMode) break; // å†æ¬¡æ£€æŸ¥
                    
                    calculatePageRange(pageNum);
                    const range = pageRanges.get(pageNum);
                    if (range) {
                        lastEndIndex = range.end;
                        pageNum++;
                    } else {
                        break;
                    }
                }
                
                // å¦‚æœå·²ç»å–æ¶ˆæŠ˜å æ¨¡å¼ï¼Œé€€å‡ºè®¡ç®—
                if (!isCollapseMode) {
                    console.log('âš ï¸ æŠ˜å æ¨¡å¼å·²å–æ¶ˆï¼Œåœæ­¢è®¡ç®—');
                    isCalculatingPages = false;
                    calculationProgress = 0;
                    return;
                }
                
                // è®¡ç®—è¿›åº¦
                calculationProgress = Math.min(99, Math.floor((lastEndIndex / allLines.length) * 100));
                console.log(`ğŸ“Š è®¡ç®—è¿›åº¦: ${calculationProgress}% (å·²è®¡ç®— ${pageNum - 1} é¡µï¼Œå¤„ç†åˆ°ç¬¬ ${lastEndIndex} è¡Œ)`);
                updatePagination(); // æ›´æ–°è¿›åº¦æ˜¾ç¤º
                
                // è®©å‡ºCPUæ—¶é—´ï¼Œä¿æŒé¡µé¢å“åº”
                await new Promise(resolve => setTimeout(resolve, 10));
            }
            
            calculationProgress = 100;
            isCalculatingPages = false;
            
            console.log(`âœ… æ‰€æœ‰é¡µé¢è®¡ç®—å®Œæˆï¼å…± ${pageNum - 1} é¡µ`);
            updatePagination(); // æœ€ç»ˆæ›´æ–°æ˜¾ç¤ºç²¾ç¡®å€¼
        }
        
        // æå–æ—¥å¿—çš„æ ¸å¿ƒå†…å®¹ï¼ˆå»é™¤æ—¶é—´æˆ³ï¼‰
        function extractLogContent(line) {
            const content = (line.content || line).toString();
            
            // å°è¯•ç§»é™¤å¸¸è§çš„æ—¶é—´æˆ³æ ¼å¼
            // æ ¼å¼1: 2025-11-20 08:16:50.054
            let result = content.replace(/^\d{4}-\d{2}-\d{2}\s+\d{2}:\d{2}:\d{2}\.\d+\s*/, '');
            
            // æ ¼å¼2: [2025-11-20 08:16:50.054]
            result = result.replace(/^\[\d{4}-\d{2}-\d{2}\s+\d{2}:\d{2}:\d{2}(\.\d+)?\]\s*/, '');
            
            // æ ¼å¼3: 2025-11-20 08:16:50
            result = result.replace(/^\d{4}-\d{2}-\d{2}\s+\d{2}:\d{2}:\d{2}\s*/, '');
            
            // æ ¼å¼4: [2025-11-20 08:16:50]
            result = result.replace(/^\[\d{4}-\d{2}-\d{2}\s+\d{2}:\d{2}:\d{2}\]\s*/, '');
            
            // æ ¼å¼5: 2025/11/20 08:16:50.054
            result = result.replace(/^\d{4}\/\d{2}\/\d{2}\s+\d{2}:\d{2}:\d{2}(\.\d+)?\s*/, '');
            
            return result.trim();
        }
        
        // æŠ˜å é‡å¤çš„æ—¥å¿—è¡Œï¼ˆæ”¯æŒå¤šè¡Œæ¨¡å¼é‡å¤ï¼‰
        function collapseRepeatedLines(lines, startIndex) {
            console.log('ğŸ“ å¼€å§‹æŠ˜å åˆ†æï¼Œæ€»è¡Œæ•°:', lines.length);
            const result = [];
            let i = 0;
            let totalCollapsed = 0;
            
            while (i < lines.length) {
                // å°è¯•ä¸åŒçš„æ¨¡å¼é•¿åº¦ï¼ˆ1è¡Œã€2è¡Œã€3è¡Œ...æœ€å¤š10è¡Œï¼‰
                let bestPatternLength = 0;
                let bestRepeatCount = 0;
                
                for (let patternLength = 1; patternLength <= Math.min(10, Math.floor((lines.length - i) / 2)); patternLength++) {
                    // è·å–å½“å‰æ¨¡å¼ï¼ˆå»é™¤æ—¶é—´æˆ³ï¼‰
                    const pattern = [];
                    for (let k = 0; k < patternLength; k++) {
                        if (i + k >= lines.length) break;
                        const content = extractLogContent(lines[i + k]);
                        pattern.push(content);
                    }
                    
                    if (pattern.length < patternLength) break;
                    
                    // æ£€æµ‹è¿™ä¸ªæ¨¡å¼é‡å¤äº†å¤šå°‘æ¬¡
                    let repeatCount = 1;
                    let j = i + patternLength;
                    
                    while (j + patternLength <= lines.length) {
                        let matches = true;
                        for (let k = 0; k < patternLength; k++) {
                            const currentContent = extractLogContent(lines[j + k]);
                            if (currentContent !== pattern[k]) {
                                matches = false;
                                break;
                            }
                        }
                        
                        if (matches) {
                            repeatCount++;
                            j += patternLength;
                        } else {
                            break;
                        }
                    }
                    
                    // å¦‚æœè¿™ä¸ªæ¨¡å¼è‡³å°‘é‡å¤2æ¬¡ï¼Œä¸”æ¯”ä¹‹å‰æ‰¾åˆ°çš„æ›´å¥½
                    if (repeatCount >= 2 && repeatCount > bestRepeatCount) {
                        bestPatternLength = patternLength;
                        bestRepeatCount = repeatCount;
                    }
                }
                
                if (bestPatternLength > 0 && bestRepeatCount >= 2) {
                    // æ‰¾åˆ°äº†é‡å¤æ¨¡å¼
                    const firstLineNumber = lines[i].lineNumber || (startIndex + i + 1);
                    const groupId = `group_${firstLineNumber}`;
                    const totalLines = bestPatternLength * bestRepeatCount;
                    
                    console.log(`âœ… æ‰¾åˆ°é‡å¤æ¨¡å¼ï¼šä»è¡Œ ${firstLineNumber} å¼€å§‹ï¼Œ${bestPatternLength} è¡Œä¸ºä¸€ç»„ï¼Œé‡å¤ ${bestRepeatCount} æ¬¡ï¼Œå…± ${totalLines} è¡Œ`);
                    if (bestPatternLength > 1) {
                        console.log('  æ¨¡å¼ç¬¬ä¸€è¡Œ:', extractLogContent(lines[i]).substring(0, 80));
                    }
                    totalCollapsed++;
                    
                    result.push({
                        isCollapsed: true,
                        groupId: groupId,
                        patternLength: bestPatternLength,
                        repeatCount: bestRepeatCount,
                        lines: lines.slice(i, i + totalLines),
                        firstLine: lines[i],
                        isExpanded: expandedGroups.has(groupId)
                    });
                    
                    i += totalLines;
                } else {
                    // æ²¡æœ‰é‡å¤ï¼Œç›´æ¥æ·»åŠ 
                    result.push(lines[i]);
                    i++;
                }
            }
            
            console.log(`ğŸ“Š æŠ˜å å®Œæˆï¼æ‰¾åˆ° ${totalCollapsed} ä¸ªé‡å¤ç»„ï¼Œæœ€ç»ˆè¾“å‡º ${result.length} æ¡`);
            return result;
        }
        
        // æ¸²æŸ“æŠ˜å ç»„
        function renderCollapsedGroup(container, group) {
            const lineDiv = document.createElement('div');
            lineDiv.className = 'log-line collapsed';
            lineDiv.dataset.groupId = group.groupId;
            
            // æ·»åŠ çº§åˆ«æ ·å¼
            if (group.firstLine.level) {
                lineDiv.classList.add(group.firstLine.level.toLowerCase());
            }
            
            const firstLineNumber = group.firstLine.lineNumber || group.lines[0].lineNumber;
            
            const lineNumber = document.createElement('span');
            lineNumber.className = 'log-line-number';
            lineNumber.textContent = firstLineNumber.toString();
            
            const lineContent = document.createElement('span');
            lineContent.className = 'log-line-content';
            
            // æ˜¾ç¤ºæ¨¡å¼çš„ç¬¬ä¸€è¡Œ
            const content = group.firstLine.content || group.firstLine;
            let highlightedContent = highlightKeywords(content, currentSearchKeyword);
            
            // æ·»åŠ é‡å¤æ¬¡æ•°å¾½ç« 
            if (group.patternLength === 1) {
                // å•è¡Œé‡å¤
                highlightedContent += `<span class="repeat-count" title="ç‚¹å‡»${group.isExpanded ? 'æŠ˜å ' : 'å±•å¼€'}è¯¦æƒ…">é‡å¤ ${group.repeatCount} æ¬¡</span>`;
            } else {
                // å¤šè¡Œæ¨¡å¼é‡å¤
                highlightedContent += `<span class="repeat-count" title="ç‚¹å‡»${group.isExpanded ? 'æŠ˜å ' : 'å±•å¼€'}è¯¦æƒ…">${group.patternLength} è¡Œä¸ºä¸€ç»„ï¼Œé‡å¤ ${group.repeatCount} æ¬¡</span>`;
            }
            
            lineContent.innerHTML = highlightedContent;
            
            // ç‚¹å‡»å±•å¼€/æŠ˜å 
            lineDiv.onclick = () => {
                toggleGroup(group.groupId);
            };
            
            lineDiv.appendChild(lineNumber);
            lineDiv.appendChild(lineContent);
            container.appendChild(lineDiv);
            
            // å¦‚æœå·²å±•å¼€ï¼Œæ˜¾ç¤ºæ‰€æœ‰è¡Œ
            if (group.isExpanded) {
                group.lines.forEach((line, index) => {
                    const expandedLineDiv = document.createElement('div');
                    expandedLineDiv.className = 'log-line';
                    expandedLineDiv.style.marginLeft = '20px';
                    expandedLineDiv.style.opacity = '0.8';
                    
                    // æ¯ä¸ªæ¨¡å¼ç»„ä¹‹é—´åŠ ä¸ªåˆ†éš”çº¿
                    if (index > 0 && index % group.patternLength === 0) {
                        expandedLineDiv.style.borderTop = '1px dashed rgba(139, 92, 246, 0.3)';
                        expandedLineDiv.style.marginTop = '3px';
                        expandedLineDiv.style.paddingTop = '3px';
                    }
                    
                    const actualLineNumber = line.lineNumber || (firstLineNumber + index);
                    
                    const expandedLineNumber = document.createElement('span');
                    expandedLineNumber.className = 'log-line-number';
                    expandedLineNumber.textContent = actualLineNumber.toString();
                    
                    const expandedLineContent = document.createElement('span');
                    expandedLineContent.className = 'log-line-content';
                    const expandedContent = line.content || line;
                    expandedLineContent.innerHTML = highlightKeywords(expandedContent, currentSearchKeyword);
                    
                    expandedLineDiv.appendChild(expandedLineNumber);
                    expandedLineDiv.appendChild(expandedLineContent);
                    container.appendChild(expandedLineDiv);
                });
            }
        }
        
        // æ¸²æŸ“å•æ¡æ—¥å¿—
        function renderSingleLine(container, line, startIndex, index) {
            const lineDiv = document.createElement('div');
            lineDiv.className = 'log-line';
            
            const actualLineNumber = line.lineNumber || startIndex + index + 1;
            
            // æ ¹æ®æ—¥å¿—çº§åˆ«æ·»åŠ æ ·å¼
            if (line.level) {
                lineDiv.classList.add(line.level.toLowerCase());
            }
            
            // å¦‚æœæ˜¯ä¹¦ç­¾è¡Œï¼Œæ·»åŠ ä¹¦ç­¾æ ‡è®°
            if (bookmarks.has(actualLineNumber)) {
                lineDiv.style.backgroundColor = 'rgba(255, 193, 7, 0.1)';
                lineDiv.style.borderRight = '3px solid #ffc107';
            }
            
            const lineNumber = document.createElement('span');
            lineNumber.className = 'log-line-number';
            lineNumber.textContent = actualLineNumber.toString();
            
            // å¦‚æœæ˜¯ä¹¦ç­¾ï¼Œæ˜¾ç¤ºä¹¦ç­¾å›¾æ ‡
            if (bookmarks.has(actualLineNumber)) {
                lineNumber.textContent = 'ğŸ“Œ ' + lineNumber.textContent;
            }
            
            const lineContent = document.createElement('span');
            lineContent.className = 'log-line-content';
            
            const content = line.content || line;
            
            // å°è¯•è§£æJSON/XMLå¹¶æ·»åŠ åˆ°æ—¥å¿—å†…å®¹åé¢
            const parsedStructure = detectAndParseStructuredData(content);
            
            // å¢å¼ºé«˜äº®åŠŸèƒ½
            let highlightedContent = highlightKeywords(content, currentSearchKeyword);
            
            // å¦‚æœæœ‰æ³¨é‡Šï¼Œæ·»åŠ æ³¨é‡Šå¾½ç« 
            if (comments.has(actualLineNumber)) {
                highlightedContent += `<span class="comment-badge" onclick="event.stopPropagation(); editComment(${actualLineNumber})" title="ç‚¹å‡»ç¼–è¾‘æ³¨é‡Š">ğŸ“ æœ‰æ³¨é‡Š</span>`;
            }
            
            lineContent.innerHTML = highlightedContent;
            
            // æ·»åŠ å³é”®èœå•å¤åˆ¶åŠŸèƒ½
            lineDiv.oncontextmenu = (e) => {
                e.preventDefault();
                showContextMenu(e, content, actualLineNumber);
            };
            
            // æ·»åŠ åŒå‡»ä¹¦ç­¾åŠŸèƒ½ï¼ˆåªæœ‰åœ¨æ²¡æœ‰é€‰ä¸­æ–‡æœ¬æ—¶æ‰è§¦å‘ï¼‰
            lineDiv.ondblclick = (e) => {
                // æ£€æŸ¥æ˜¯å¦æœ‰æ–‡æœ¬è¢«é€‰ä¸­
                const selection = window.getSelection();
                const selectedText = selection.toString();
                
                // å¦‚æœæœ‰æ–‡æœ¬è¢«é€‰ä¸­ï¼Œè¯´æ˜ç”¨æˆ·æƒ³å¤åˆ¶ï¼Œä¸è§¦å‘ä¹¦ç­¾
                if (selectedText && selectedText.trim().length > 0) {
                    console.log('ğŸ“‹ ç”¨æˆ·é€‰ä¸­äº†æ–‡æœ¬ï¼Œä¸è§¦å‘ä¹¦ç­¾');
                    return;
                }
                
                e.stopPropagation();
                toggleBookmark(actualLineNumber);
            };
            
            // æ·»åŠ ç‚¹å‡»è·³è½¬åŠŸèƒ½ï¼ˆä»…åœ¨æœç´¢æ¨¡å¼ä¸‹ï¼‰
            if (currentSearchKeyword || isFiltering) {
                lineDiv.onclick = (e) => {
                    // å¦‚æœç‚¹å‡»çš„æ˜¯æ³¨é‡Šå¾½ç« ï¼Œä¸è·³è½¬
                    if (e.target.classList.contains('comment-badge')) {
                        return;
                    }
                    jumpToLineInFullLog(actualLineNumber);
                };
                lineDiv.style.cursor = 'pointer';
                lineDiv.title = 'ç‚¹å‡»è·³è½¬åˆ°å®Œæ•´æ—¥å¿—ä¸­çš„æ­¤è¡Œ';
            }
            
            lineDiv.appendChild(lineNumber);
            lineDiv.appendChild(lineContent);
            
            // å¦‚æœè§£æå‡ºJSON/XMLç»“æ„ï¼Œæ·»åŠ åˆ°ä¸‹æ–¹
            if (parsedStructure) {
                const structDiv = document.createElement('div');
                structDiv.innerHTML = parsedStructure;
                lineDiv.appendChild(structDiv);
            }
            
            // å¦‚æœæœ‰æ³¨é‡Šï¼Œåœ¨ä¸‹æ–¹æ˜¾ç¤ºæ³¨é‡Šå†…å®¹
            if (comments.has(actualLineNumber)) {
                const commentDiv = document.createElement('div');
                commentDiv.className = 'log-comment';
                commentDiv.textContent = 'ğŸ“ ' + comments.get(actualLineNumber);
                lineDiv.appendChild(commentDiv);
            }
            
            container.appendChild(lineDiv);
        }
        
        // åˆ‡æ¢æŠ˜å ç»„
        function toggleGroup(groupId) {
            if (expandedGroups.has(groupId)) {
                expandedGroups.delete(groupId);
            } else {
                expandedGroups.add(groupId);
            }
            renderLines();
        }
        
        // åˆ‡æ¢æŠ˜å æ¨¡å¼
        function toggleCollapseMode() {
            isCollapseMode = document.getElementById('collapseRepeated').checked;
            console.log('ğŸ” åˆ‡æ¢æŠ˜å æ¨¡å¼:', isCollapseMode);
            
            expandedGroups.clear(); // æ¸…ç©ºå±•å¼€çŠ¶æ€
            
            // ç»Ÿä¸€å¤„ç†æ•°æ®å˜æ›´
            handleDataChange();
        }
        
        // å¢å¼ºçš„å…³é”®è¯é«˜äº®åŠŸèƒ½ - ä½¿ç”¨è‡ªå®šä¹‰è§„åˆ™
        function highlightKeywords(content, keyword) {
            if (!content) return '';
            
            let result = escapeHtml(content);
            
            // åº”ç”¨æ‰€æœ‰å¯ç”¨çš„è‡ªå®šä¹‰é«˜äº®è§„åˆ™
            customHighlightRules.forEach(rule => {
                if (!rule.enabled) return;
                
                try {
                    if (rule.type === 'text') {
                        // æ–‡æœ¬åŒ¹é…
                        const escaped = escapeRegex(rule.pattern);
                        const regex = new RegExp('(' + escaped + ')', 'gi');
                        result = result.replace(regex, function(match) {
                            return `<span class="custom-highlight" style="background-color: ${rule.bgColor}; color: ${rule.textColor};">${match}</span>`;
                        });
                    } else {
                        // æ­£åˆ™è¡¨è¾¾å¼åŒ¹é…
                        const regex = new RegExp(rule.pattern, 'g');
                        
                        // æ ¹æ®è§„åˆ™åç§°åˆ¤æ–­æ˜¯å¦éœ€è¦æ·»åŠ ç‚¹å‡»äº‹ä»¶
                        if (rule.name === 'çº¿ç¨‹å') {
                            // çº¿ç¨‹å - æ·»åŠ ç­›é€‰å›¾æ ‡
                            result = result.replace(regex, function(match) {
                                // æå–æ–¹æ‹¬å·å†…çš„çº¿ç¨‹å
                                const threadNameMatch = match.match(/\[([a-zA-Z][a-zA-Z0-9-_]*)\]/);
                                if (threadNameMatch) {
                                    const threadName = threadNameMatch[1];
                                    return `<span class="custom-highlight" style="background-color: ${rule.bgColor}; color: ${rule.textColor};">${match}<span class="filter-icon" onclick="event.stopPropagation(); filterByThreadName('${threadName.replace(/'/g, "\\'")}')", title="ç‚¹å‡»ç­›é€‰çº¿ç¨‹: ${threadName}">ğŸ”</span></span>`;
                                }
                                return `<span class="custom-highlight" style="background-color: ${rule.bgColor}; color: ${rule.textColor};">${match}</span>`;
                            });
                        } else if (rule.name === 'ç±»å') {
                            // ç±»å - æ·»åŠ ç­›é€‰å›¾æ ‡
                            result = result.replace(regex, function(match) {
                                const className = match.trim();
                                return `<span class="custom-highlight" style="background-color: ${rule.bgColor}; color: ${rule.textColor};">${match}<span class="filter-icon" onclick="event.stopPropagation(); filterByClassName('${className.replace(/'/g, "\\'")}')", title="ç‚¹å‡»ç­›é€‰ç±»: ${className}">ğŸ”</span></span>`;
                            });
                        } else if (rule.name === 'æ–¹æ³•å') {
                            // æ–¹æ³•å - æ·»åŠ ç­›é€‰å›¾æ ‡ï¼ˆåŒ¹é… [methodName:lineNumber]ï¼‰
                            result = result.replace(regex, function(match) {
                                // æå–æ–¹æ‹¬å·å†…çš„æ–¹æ³•åï¼ˆå»æ‰è¡Œå·ï¼‰
                                const methodMatch = match.match(/\[([a-zA-Z_][a-zA-Z0-9_]*):\d+\]/);
                                if (methodMatch) {
                                    const methodName = methodMatch[1];
                                    return `<span class="custom-highlight" style="background-color: ${rule.bgColor}; color: ${rule.textColor};">${match}<span class="filter-icon" onclick="event.stopPropagation(); filterByMethodName('${methodName.replace(/'/g, "\\'")}')", title="ç‚¹å‡»ç­›é€‰æ–¹æ³•: ${methodName}">ğŸ”</span></span>`;
                                }
                                return `<span class="custom-highlight" style="background-color: ${rule.bgColor}; color: ${rule.textColor};">${match}</span>`;
                            });
                        } else {
                            // å…¶ä»–è§„åˆ™ - ä¸æ·»åŠ ç‚¹å‡»äº‹ä»¶
                            result = result.replace(regex, function(match) {
                                return `<span class="custom-highlight" style="background-color: ${rule.bgColor}; color: ${rule.textColor};">${match}</span>`;
                            });
                        }
                    }
                } catch (e) {
                    console.error(`è§„åˆ™ "${rule.name}" åº”ç”¨å¤±è´¥:`, e);
                }
            });
            
            // é«˜äº®æœç´¢å…³é”®è¯ï¼ˆæœ€åå¤„ç†ï¼Œé¿å…è¦†ç›–å…¶ä»–é«˜äº®ï¼‰
            if (keyword) {
                const regex = new RegExp('(' + escapeRegex(keyword) + ')', 'gi');
                result = result.replace(regex, '<span class="highlight">$1</span>');
            }
            
            return result;
        }
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        function escapeRegex(str) {
            return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        }
        
        function search() {
            const keyword = document.getElementById('searchInput').value;
            const isRegex = document.getElementById('regexMode').checked;
            const isReverse = document.getElementById('reverseMode').checked;
            
            if (!keyword) {
                vscode.postMessage({
                    command: 'refresh'
                });
                currentSearchKeyword = '';
                return;
            }
            
            // ä¿å­˜æœç´¢å…³é”®è¯ç”¨äºé«˜äº®
            currentSearchKeyword = keyword;
            
            if (isRegex) {
                vscode.postMessage({
                    command: 'regexSearch',
                    pattern: keyword,
                    flags: 'gi',
                    reverse: isReverse
                });
            } else {
                vscode.postMessage({
                    command: 'search',
                    keyword: keyword,
                    reverse: isReverse
                });
            }
            
            if (isReverse) {
                showToast('ğŸ”½ åå‘æœç´¢ä¸­...');
            }
        }
        
        function applyFilter() {
            const levels = [];
            const errorChecked = document.getElementById('filterError').checked;
            const warnChecked = document.getElementById('filterWarn').checked;
            const infoChecked = document.getElementById('filterInfo').checked;
            const debugChecked = document.getElementById('filterDebug').checked;
            const otherChecked = document.getElementById('filterOther').checked;
            
            if (errorChecked) { levels.push('ERROR'); }
            if (warnChecked) { levels.push('WARN'); }
            if (infoChecked) { levels.push('INFO'); }
            if (debugChecked) { levels.push('DEBUG'); }
            
            console.log('Filter applied:', levels);
            console.log('Checkboxes:', { errorChecked, warnChecked, infoChecked, debugChecked, otherChecked });
            
            // æ›´æ–°å…¨é€‰æ¡†çŠ¶æ€
            const allChecked = errorChecked && warnChecked && infoChecked && debugChecked && otherChecked;
            const allUnchecked = !errorChecked && !warnChecked && !infoChecked && !debugChecked && !otherChecked;
            const filterAllCheckbox = document.getElementById('filterAll');
            
            console.log('ğŸ”µ æ£€æŸ¥å…¨é€‰çŠ¶æ€ - allChecked:', allChecked, 'allUnchecked:', allUnchecked);
            
            if (allChecked) {
                filterAllCheckbox.checked = true;
                filterAllCheckbox.indeterminate = false;
            } else if (allUnchecked) {
                filterAllCheckbox.checked = false;
                filterAllCheckbox.indeterminate = false;
            } else {
                filterAllCheckbox.indeterminate = true;
            }
            
            // å¦‚æœå…¨éƒ¨é€‰ä¸­ï¼Œåˆ·æ–°æ˜¾ç¤ºæ‰€æœ‰æ•°æ®
            if (allChecked) {
                console.log('âš ï¸ å…¨éƒ¨é€‰ä¸­ï¼Œåˆ·æ–°...');
                if (!currentSearchKeyword) {
                    vscode.postMessage({ command: 'refresh' });
                }
                return;
            }
            
            // å¦‚æœå…¨éƒ¨ä¸é€‰ï¼Œæ˜¾ç¤ºç©º
            if (levels.length === 0) {
                console.log('âš ï¸ æ²¡æœ‰é€‰æ‹©ä»»ä½•çº§åˆ«');
                allLines = [];
                renderLines();
                return;
            }
            
            // å‘é€ç­›é€‰è¯·æ±‚
            console.log('ğŸ“¤ å‘é€è¿‡æ»¤è¯·æ±‚:', levels);
            vscode.postMessage({
                command: 'filterByLevel',
                levels: levels
            });
        }
        
        function toggleAll() {
            const filterAll = document.getElementById('filterAll');
            const checked = filterAll.checked;
            
            document.getElementById('filterError').checked = checked;
            document.getElementById('filterWarn').checked = checked;
            document.getElementById('filterInfo').checked = checked;
            document.getElementById('filterDebug').checked = checked;
            document.getElementById('filterOther').checked = checked;
            
            filterAll.indeterminate = false;
            applyFilter();
        }
        
        function showStats() {
            vscode.postMessage({
                command: 'getStatistics'
            });
        }
        
        function showStatsModal(stats) {
            const grid = document.getElementById('statsGrid');
            
            // è½¬æ¢ Map ä¸ºæ•°ç»„å¹¶æ’åº
            const classStats = stats.classCounts ? 
                Array.from(Object.entries(stats.classCounts)).sort((a, b) => b[1] - a[1]).slice(0, 10) : [];
            const methodStats = stats.methodCounts ? 
                Array.from(Object.entries(stats.methodCounts)).sort((a, b) => b[1] - a[1]).slice(0, 10) : [];
            const threadStats = stats.threadCounts ? 
                Array.from(Object.entries(stats.threadCounts)).sort((a, b) => b[1] - a[1]).slice(0, 10) : [];
            
            grid.innerHTML = `
                <div class="stats-card">
                    <h3>æ€»è¡Œæ•°</h3>
                    <div class="value">${stats.totalLines}</div>
                </div>
                <div class="stats-card">
                    <h3>ERROR</h3>
                    <div class="value" style="color: #f14c4c;">${stats.errorCount}</div>
                </div>
                <div class="stats-card">
                    <h3>WARN</h3>
                    <div class="value" style="color: #cca700;">${stats.warnCount}</div>
                </div>
                <div class="stats-card">
                    <h3>INFO</h3>
                    <div class="value" style="color: #4fc1ff;">${stats.infoCount}</div>
                </div>
                <div class="stats-card">
                    <h3>DEBUG</h3>
                    <div class="value" style="color: #b267e6;">${stats.debugCount}</div>
                </div>
                <div class="stats-card">
                    <h3>å…¶ä»–</h3>
                    <div class="value">${stats.otherCount}</div>
                </div>
            `;
            
            if (stats.timeRange && stats.timeRange.start) {
                grid.innerHTML += `
                    <div class="stats-card" style="grid-column: 1 / -1;">
                        <h3>æ—¶é—´èŒƒå›´</h3>
                        <div style="font-size: 14px;">
                            ${new Date(stats.timeRange.start).toLocaleString()} - 
                            ${new Date(stats.timeRange.end).toLocaleString()}
                        </div>
                    </div>
                `;
            }
            
            // æ·»åŠ ç±»åç»Ÿè®¡
            if (classStats.length > 0) {
                grid.innerHTML += `
                    <div class="stats-card" style="grid-column: 1 / -1;">
                        <h3>ğŸ“Š æœ€æ´»è·ƒçš„ç±» (Top 10)</h3>
                        <div style="font-size: 13px; margin-top: 10px;">
                            ${classStats.map(([name, count]) => 
                                `<div style="padding: 5px 0; border-bottom: 1px solid var(--vscode-panel-border); cursor: pointer; transition: background-color 0.2s;" 
                                      onmouseover="this.style.backgroundColor='var(--vscode-list-hoverBackground)'" 
                                      onmouseout="this.style.backgroundColor='transparent'"
                                      onclick="filterByClassName('${name.replace(/'/g, "\\'")}')"
                                      title="ç‚¹å‡»ç­›é€‰åŒ…å«æ­¤ç±»çš„æ—¥å¿—">
                                    <span style="font-weight: bold; color: var(--vscode-textLink-foreground);">${name}</span>
                                    <span style="float: right; color: var(--vscode-descriptionForeground);">${count} æ¬¡</span>
                                </div>`
                            ).join('')}
                        </div>
                    </div>
                `;
            }
            
            // æ·»åŠ æ–¹æ³•åç»Ÿè®¡
            if (methodStats.length > 0) {
                grid.innerHTML += `
                    <div class="stats-card" style="grid-column: 1 / -1;">
                        <h3>ğŸ”§ æœ€å¸¸è°ƒç”¨çš„æ–¹æ³• (Top 10)</h3>
                        <div style="font-size: 13px; margin-top: 10px;">
                            ${methodStats.map(([name, count]) => 
                                `<div style="padding: 5px 0; border-bottom: 1px solid var(--vscode-panel-border); cursor: pointer; transition: background-color 0.2s;" 
                                      onmouseover="this.style.backgroundColor='var(--vscode-list-hoverBackground)'" 
                                      onmouseout="this.style.backgroundColor='transparent'"
                                      onclick="filterByMethodName('${name.replace(/'/g, "\\'")}')"
                                      title="ç‚¹å‡»ç­›é€‰åŒ…å«æ­¤æ–¹æ³•çš„æ—¥å¿—">
                                    <span style="font-weight: bold; color: var(--vscode-textLink-foreground);">${name}</span>
                                    <span style="float: right; color: var(--vscode-descriptionForeground);">${count} æ¬¡</span>
                                </div>`
                            ).join('')}
                        </div>
                    </div>
                `;
            }
            
            // æ·»åŠ çº¿ç¨‹åç»Ÿè®¡
            if (threadStats.length > 0) {
                grid.innerHTML += `
                    <div class="stats-card" style="grid-column: 1 / -1;">
                        <h3>ğŸ§µ æœ€æ´»è·ƒçš„çº¿ç¨‹ (Top 10)</h3>
                        <div style="font-size: 13px; margin-top: 10px;">
                            ${threadStats.map(([name, count]) => 
                                `<div style="padding: 5px 0; border-bottom: 1px solid var(--vscode-panel-border); cursor: pointer; transition: background-color 0.2s;" 
                                      onmouseover="this.style.backgroundColor='var(--vscode-list-hoverBackground)'" 
                                      onmouseout="this.style.backgroundColor='transparent'"
                                      onclick="filterByThreadName('${name.replace(/'/g, "\\'")}')"
                                      title="ç‚¹å‡»ç­›é€‰åŒ…å«æ­¤çº¿ç¨‹çš„æ—¥å¿—">
                                    <span style="font-weight: bold; color: var(--vscode-textLink-foreground);">${name}</span>
                                    <span style="float: right; color: var(--vscode-descriptionForeground);">${count} æ¬¡</span>
                                </div>`
                            ).join('')}
                        </div>
                    </div>
                `;
            }
            
            document.getElementById('statsModal').style.display = 'block';
        }
        
        function closeStatsModal() {
            document.getElementById('statsModal').style.display = 'none';
        }
        
        // ========== ä¹¦ç­¾åŠŸèƒ½ ==========
        function toggleBookmark(lineNumber) {
            if (bookmarks.has(lineNumber)) {
                bookmarks.delete(lineNumber);
                console.log('â– ç§»é™¤ä¹¦ç­¾:', lineNumber);
            } else {
                bookmarks.add(lineNumber);
                console.log('â• æ·»åŠ ä¹¦ç­¾:', lineNumber);
            }
            renderLines(); // é‡æ–°æ¸²æŸ“ä»¥æ˜¾ç¤ºä¹¦ç­¾æ ‡è®°
        }
        
        function showBookmarksModal() {
            const modal = document.getElementById('bookmarksModal');
            const list = document.getElementById('bookmarksList');
            
            if (bookmarks.size === 0) {
                list.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--vscode-descriptionForeground);">æš‚æ— ä¹¦ç­¾<br>åŒå‡»æ—¥å¿—è¡Œå¯æ·»åŠ ä¹¦ç­¾</div>';
            } else {
                const bookmarkArray = Array.from(bookmarks).sort((a, b) => a - b);
                list.innerHTML = bookmarkArray.map(lineNum => {
                    const line = allLines.find(l => l.lineNumber === lineNum);
                    const content = line ? (line.content || line) : 'ï¼ˆå·²ä¸å­˜åœ¨ï¼‰';
                    const preview = content.substring(0, 100) + (content.length > 100 ? '...' : '');
                    
                    return `
                        <div style="padding: 10px; margin-bottom: 10px; background-color: var(--vscode-editorWidget-background); border-radius: 5px; border-left: 3px solid #ffc107; cursor: pointer; transition: background-color 0.2s;"
                             onmouseover="this.style.backgroundColor='var(--vscode-list-hoverBackground)'"
                             onmouseout="this.style.backgroundColor='var(--vscode-editorWidget-background)'"
                             onclick="jumpToBookmark(${lineNum})">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                                <span style="font-weight: bold; color: var(--vscode-textLink-foreground);">ğŸ“Œ è¡Œ ${lineNum}</span>
                                <button onclick="event.stopPropagation(); removeBookmark(${lineNum})" style="padding: 2px 8px; font-size: 11px;">åˆ é™¤</button>
                            </div>
                            <div style="font-size: 12px; color: var(--vscode-descriptionForeground); font-family: 'Consolas', monospace; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
                                ${escapeHtml(preview)}
                            </div>
                        </div>
                    `;
                }).join('');
            }
            
            modal.style.display = 'block';
        }
        
        function closeBookmarksModal() {
            document.getElementById('bookmarksModal').style.display = 'none';
        }
        
        function jumpToBookmark(lineNumber) {
            closeBookmarksModal();
            jumpToLine(lineNumber);
        }
        
        function removeBookmark(lineNumber) {
            bookmarks.delete(lineNumber);
            showBookmarksModal(); // åˆ·æ–°ä¹¦ç­¾åˆ—è¡¨
            renderLines(); // é‡æ–°æ¸²æŸ“
        }
        
        // ==========  æ³¨é‡ŠåŠŸèƒ½ ==========
        let currentCommentLineNumber = null; // å½“å‰æ­£åœ¨ç¼–è¾‘æ³¨é‡Šçš„è¡Œå·
        let enableJsonParse = true; // æ˜¯å¦å¯ç”¨JSON/XMLè§£æ
        
        // è‡ªå®šä¹‰é«˜äº®è§„åˆ™
        let customHighlightRules = [];
        let editingRuleIndex = -1; // æ­£åœ¨ç¼–è¾‘çš„è§„åˆ™ç´¢å¼•
        
        // åˆå§‹åŒ–é¢„è®¾è§„åˆ™
        function initDefaultHighlightRules() {
            customHighlightRules = [
                { id: 1, name: 'æ—¥å¿—çº§åˆ« - ERROR', type: 'regex', pattern: '\\b(ERROR|FATAL|SEVERE)\\b', bgColor: '#f14c4c', textColor: '#ffffff', enabled: true, builtin: true },
                { id: 2, name: 'æ—¥å¿—çº§åˆ« - WARN', type: 'regex', pattern: '\\b(WARN|WARNING)\\b', bgColor: '#cca700', textColor: '#ffffff', enabled: true, builtin: true },
                { id: 3, name: 'æ—¥å¿—çº§åˆ« - INFO', type: 'regex', pattern: '\\b(INFO)\\b', bgColor: '#4fc1ff', textColor: '#000000', enabled: true, builtin: true },
                { id: 4, name: 'æ—¥å¿—çº§åˆ« - DEBUG', type: 'regex', pattern: '\\b(DEBUG|TRACE|VERBOSE)\\b', bgColor: '#b267e6', textColor: '#ffffff', enabled: true, builtin: true },
                { id: 5, name: 'æ—¶é—´æˆ³', type: 'regex', pattern: '\\d{4}[-/]\\d{2}[-/]\\d{2}[T\\s]\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?', bgColor: '#b267e6', textColor: '#ffffff', enabled: true, builtin: true },
                { id: 6, name: 'çº¿ç¨‹å', type: 'regex', pattern: '\\[([a-zA-Z][a-zA-Z0-9-_]*)\\]', bgColor: '#06b6d4', textColor: '#ffffff', enabled: true, builtin: true },
                { id: 7, name: 'ç±»å', type: 'regex', pattern: '\\b([a-z][a-z0-9_]*(?:\\.[a-z][a-z0-9_]*)*\\.[A-Z][a-zA-Z0-9_]*)\\b', bgColor: '#10b981', textColor: '#ffffff', enabled: true, builtin: true },
                { id: 8, name: 'æ–¹æ³•å', type: 'regex', pattern: '\\[([a-zA-Z_][a-zA-Z0-9_]*):\\d+\\]', bgColor: '#f59e0b', textColor: '#ffffff', enabled: true, builtin: true }
            ];
            loadCustomRulesFromStorage();
        }
        
        // ä» localStorage åŠ è½½è‡ªå®šä¹‰è§„åˆ™
        function loadCustomRulesFromStorage() {
            try {
                const saved = localStorage.getItem('customHighlightRules');
                if (saved) {
                    const customRules = JSON.parse(saved);
                    // åˆå¹¶å†…ç½®è§„åˆ™å’Œè‡ªå®šä¹‰è§„åˆ™
                    customHighlightRules = customHighlightRules.concat(customRules);
                }
            } catch (e) {
                console.error('åŠ è½½è‡ªå®šä¹‰è§„åˆ™å¤±è´¥:', e);
            }
        }
        
        // ä¿å­˜è‡ªå®šä¹‰è§„åˆ™åˆ° localStorage
        function saveCustomRulesToStorage() {
            try {
                // åªä¿å­˜éå†…ç½®è§„åˆ™
                const customRules = customHighlightRules.filter(r => !r.builtin);
                localStorage.setItem('customHighlightRules', JSON.stringify(customRules));
            } catch (e) {
                console.error('ä¿å­˜è‡ªå®šä¹‰è§„åˆ™å¤±è´¥:', e);
            }
        }
        
        // åˆå§‹åŒ–
        initDefaultHighlightRules();
        
        // è‡ªå®šä¹‰ç¡®è®¤å¯¹è¯æ¡†
        function showCustomConfirm(message, title = 'ç¡®è®¤') {
            return new Promise((resolve) => {
                // åˆ›å»ºé®ç½©å±‚
                const overlay = document.createElement('div');
                overlay.className = 'confirm-overlay';
                
                // åˆ›å»ºå¯¹è¯æ¡†
                const dialog = document.createElement('div');
                dialog.className = 'confirm-dialog';
                
                // æ ‡é¢˜
                const titleEl = document.createElement('div');
                titleEl.className = 'confirm-title';
                titleEl.textContent = title;
                
                // æ¶ˆæ¯
                const messageEl = document.createElement('div');
                messageEl.className = 'confirm-message';
                messageEl.textContent = message;
                
                // æŒ‰é’®å®¹å™¨
                const buttonsDiv = document.createElement('div');
                buttonsDiv.className = 'confirm-buttons';
                
                // å–æ¶ˆæŒ‰é’®
                const cancelBtn = document.createElement('button');
                cancelBtn.textContent = 'å–æ¶ˆ';
                cancelBtn.addEventListener('click', () => {
                    document.body.removeChild(overlay);
                    resolve(false);
                });
                
                // ç¡®è®¤æŒ‰é’®
                const confirmBtn = document.createElement('button');
                confirmBtn.textContent = 'ç¡®è®¤';
                confirmBtn.addEventListener('click', () => {
                    document.body.removeChild(overlay);
                    resolve(true);
                });
                
                buttonsDiv.appendChild(cancelBtn);
                buttonsDiv.appendChild(confirmBtn);
                
                dialog.appendChild(titleEl);
                dialog.appendChild(messageEl);
                dialog.appendChild(buttonsDiv);
                
                overlay.appendChild(dialog);
                document.body.appendChild(overlay);
                
                // ç‚¹å‡»é®ç½©å±‚å…³é—­
                overlay.addEventListener('click', (e) => {
                    if (e.target === overlay) {
                        document.body.removeChild(overlay);
                        resolve(false);
                    }
                });
                
                // èšç„¦ç¡®è®¤æŒ‰é’®
                confirmBtn.focus();
            });
        }
        
        // æ›´å¤šèœå•ç®¡ç†
        function toggleMoreMenu() {
            const dropdown = document.querySelector('.dropdown');
            dropdown.classList.toggle('show');
        }
        
        function closeMoreMenu() {
            const dropdown = document.querySelector('.dropdown');
            dropdown.classList.remove('show');
        }
        
        // ç‚¹å‡»å¤–éƒ¨å…³é—­ä¸‹æ‹‰èœå•
        document.addEventListener('click', function(event) {
            const dropdown = document.querySelector('.dropdown');
            if (dropdown && !dropdown.contains(event.target)) {
                dropdown.classList.remove('show');
            }
        });
        
        function addOrEditComment(lineNumber) {
            console.log('ğŸ“ addOrEditComment è¢«è°ƒç”¨ï¼Œè¡Œå·:', lineNumber);
            
            currentCommentLineNumber = lineNumber;
            const existingComment = comments.get(lineNumber) || '';
            const line = allLines.find(l => l.lineNumber === lineNumber);
            const content = line ? (line.content || line) : '';
            const preview = content.substring(0, 100) + (content.length > 100 ? '...' : '');
            
            // è®¾ç½®å¼¹çª—å†…å®¹
            document.getElementById('commentInputTitle').textContent = existingComment ? 'âœï¸ ç¼–è¾‘æ³¨é‡Š' : 'ğŸ“ æ·»åŠ æ³¨é‡Š';
            document.getElementById('commentInputLineNumber').textContent = lineNumber;
            document.getElementById('commentInputPreview').textContent = content;
            document.getElementById('commentInputText').value = existingComment;
            
            // æ˜¾ç¤ºå¼¹çª—
            document.getElementById('commentInputModal').style.display = 'block';
            
            // è‡ªåŠ¨èšç„¦åˆ°è¾“å…¥æ¡†
            setTimeout(() => {
                const textarea = document.getElementById('commentInputText');
                textarea.focus();
                textarea.select();
            }, 100);
            
            console.log('âœ… æ³¨é‡Šè¾“å…¥å¼¹çª—å·²æ˜¾ç¤º');
        }
        
        function closeCommentInputModal() {
            document.getElementById('commentInputModal').style.display = 'none';
            currentCommentLineNumber = null;
        }
        
        function confirmCommentInput() {
            if (currentCommentLineNumber === null) {
                console.log('âš ï¸ æ²¡æœ‰å½“å‰ç¼–è¾‘çš„è¡Œå·');
                return;
            }
            
            const lineNumber = currentCommentLineNumber;
            const commentText = document.getElementById('commentInputText').value;
            const existingComment = comments.get(lineNumber) || '';
            
            console.log('ğŸ“ ç¡®è®¤æ³¨é‡Šè¾“å…¥ï¼Œè¡Œå·:', lineNumber, 'ï¼Œå†…å®¹:', commentText);
            
            if (commentText.trim()) {
                comments.set(lineNumber, commentText.trim());
                console.log('âœ… æ·»åŠ æ³¨é‡Š:', lineNumber, '-', commentText.trim());
                showToast(`âœ… æ³¨é‡Šå·²${existingComment ? 'æ›´æ–°' : 'æ·»åŠ '}`);
            } else if (existingComment) {
                // å¦‚æœè¾“å…¥ç©ºç™½ä¸”åŸæ¥æœ‰æ³¨é‡Šï¼Œåˆ™åˆ é™¤
                comments.delete(lineNumber);
                console.log('âŒ åˆ é™¤æ³¨é‡Š:', lineNumber);
                showToast('âŒ æ³¨é‡Šå·²åˆ é™¤');
            }
            
            renderLines();
            closeCommentInputModal();
        }
        
        function editComment(lineNumber) {
            addOrEditComment(lineNumber);
        }
        
        function deleteComment(lineNumber) {
            if (confirm('ç¡®å®šè¦åˆ é™¤è¿™æ¡æ³¨é‡Šå—ï¼Ÿ')) {
                comments.delete(lineNumber);
                console.log('âŒ åˆ é™¤æ³¨é‡Š:', lineNumber);
                showToast('âŒ æ³¨é‡Šå·²åˆ é™¤');
                renderLines();
            }
        }
        
        function showCommentsModal() {
            const modal = document.getElementById('commentsModal');
            const list = document.getElementById('commentsList');
            
            if (comments.size === 0) {
                list.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--vscode-descriptionForeground);">æš‚æ— æ³¨é‡Š<br>å³é”®ç‚¹å‡»æ—¥å¿—è¡Œå¯æ·»åŠ æ³¨é‡Š</div>';
            } else {
                // å°†Mapè½¬ä¸ºæ•°ç»„å¹¶æŒ‰è¡Œå·æ’åº
                const commentArray = Array.from(comments.entries()).sort((a, b) => a[0] - b[0]);
                list.innerHTML = commentArray.map(([lineNum, comment]) => {
                    const line = allLines.find(l => l.lineNumber === lineNum);
                    const content = line ? (line.content || line) : 'ï¼ˆå·²ä¸å­˜åœ¨ï¼‰';
                    const preview = content.substring(0, 80) + (content.length > 80 ? '...' : '');
                    
                    return `
                        <div style="padding: 12px; margin-bottom: 10px; background-color: var(--vscode-editorWidget-background); border-radius: 5px; border-left: 3px solid #10b981;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                                <span style="font-weight: bold; color: var(--vscode-textLink-foreground); cursor: pointer;" onclick="jumpToComment(${lineNum})">ğŸ“ è¡Œ ${lineNum}</span>
                                <div style="display: flex; gap: 5px;">
                                    <button onclick="editComment(${lineNum})" style="padding: 2px 8px; font-size: 11px;">ç¼–è¾‘</button>
                                    <button onclick="deleteCommentFromList(${lineNum})" style="padding: 2px 8px; font-size: 11px;">åˆ é™¤</button>
                                </div>
                            </div>
                            <div style="font-size: 11px; color: var(--vscode-descriptionForeground); font-family: 'Consolas', monospace; margin-bottom: 5px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
                                ${escapeHtml(preview)}
                            </div>
                            <div style="background-color: rgba(16, 185, 129, 0.1); padding: 8px; border-radius: 3px; font-size: 12px; font-style: italic; color: var(--vscode-editor-foreground);">
                                ${escapeHtml(comment)}
                            </div>
                        </div>
                    `;
                }).join('');
            }
            
            modal.style.display = 'block';
        }
        
        function closeCommentsModal() {
            document.getElementById('commentsModal').style.display = 'none';
        }
        
        function jumpToComment(lineNumber) {
            closeCommentsModal();
            jumpToLine(lineNumber);
        }
        
        function deleteCommentFromList(lineNumber) {
            if (confirm('ç¡®å®šè¦åˆ é™¤è¿™æ¡æ³¨é‡Šå—ï¼Ÿ')) {
                comments.delete(lineNumber);
                showCommentsModal(); // åˆ·æ–°æ³¨é‡Šåˆ—è¡¨
                renderLines(); // é‡æ–°æ¸²æŸ“
                showToast('âŒ æ³¨é‡Šå·²åˆ é™¤');
            }
        }
        
        function showToast(message) {
            const toast = document.createElement('div');
            toast.textContent = message;
            toast.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background-color: #10b981;
                color: white;
                padding: 10px 20px;
                border-radius: 5px;
                font-weight: bold;
                z-index: 10000;
                animation: fadeInOut 2s ease-in-out;
            `;
            document.body.appendChild(toast);
            
            setTimeout(() => {
                if (document.body.contains(toast)) {
                    document.body.removeChild(toast);
                }
            }, 2000);
        }
        
        // ========== å¤åˆ¶åŠŸèƒ½ ==========
        let currentContextMenu = null;
        
        function showContextMenu(event, content, lineNumber) {
            console.log('ğŸ–±ï¸ showContextMenu è¢«è°ƒç”¨ï¼Œè¡Œå·:', lineNumber);
            
            // ç§»é™¤æ—§çš„èœå•
            if (currentContextMenu) {
                document.body.removeChild(currentContextMenu);
            }
            
            // è·å–é€‰ä¸­çš„æ–‡æœ¬
            const selectedText = window.getSelection().toString();
            
            // åˆ›å»ºèœå•
            const menu = document.createElement('div');
            menu.className = 'context-menu';
            
            // å¤åˆ¶é€‰ä¸­æ–‡æœ¬
            if (selectedText) {
                const copySelectedItem = document.createElement('div');
                copySelectedItem.className = 'context-menu-item';
                copySelectedItem.innerHTML = '<span>ğŸ“‹</span><span>å¤åˆ¶é€‰ä¸­å†…å®¹</span>';
                copySelectedItem.onclick = (e) => {
                    e.stopPropagation();
                    copyToClipboard(selectedText);
                    closeContextMenu();
                };
                menu.appendChild(copySelectedItem);
                
                // åˆ†éš”çº¿
                const separator1 = document.createElement('div');
                separator1.className = 'context-menu-separator';
                menu.appendChild(separator1);
            }
            
            // å¤åˆ¶æ•´è¡Œ
            const copyLineItem = document.createElement('div');
            copyLineItem.className = 'context-menu-item';
            copyLineItem.innerHTML = '<span>ğŸ“„</span><span>å¤åˆ¶æ•´è¡Œ</span>';
            copyLineItem.onclick = (e) => {
                e.stopPropagation();
                copyToClipboard(content);
                closeContextMenu();
            };
            menu.appendChild(copyLineItem);
            
            // åˆ†éš”çº¿
            const separator2 = document.createElement('div');
            separator2.className = 'context-menu-separator';
            menu.appendChild(separator2);
            
            // æ·»åŠ /ç§»é™¤ä¹¦ç­¾
            const bookmarkItem = document.createElement('div');
            bookmarkItem.className = 'context-menu-item';
            const isBookmarked = bookmarks.has(lineNumber);
            bookmarkItem.innerHTML = isBookmarked 
                ? '<span>âŒ</span><span>ç§»é™¤ä¹¦ç­¾</span>' 
                : '<span>ğŸ“Œ</span><span>æ·»åŠ ä¹¦ç­¾</span>';
            bookmarkItem.onclick = (e) => {
                e.stopPropagation();
                toggleBookmark(lineNumber);
                closeContextMenu();
            };
            menu.appendChild(bookmarkItem);
            
            // æ·»åŠ /ç¼–è¾‘æ³¨é‡Š
            const commentItem = document.createElement('div');
            commentItem.className = 'context-menu-item';
            const hasComment = comments.has(lineNumber);
            commentItem.innerHTML = hasComment
                ? '<span>âœï¸</span><span>ç¼–è¾‘æ³¨é‡Š</span>'
                : '<span>ğŸ“</span><span>æ·»åŠ æ³¨é‡Š</span>';
            commentItem.onclick = (e) => {
                console.log('ğŸ–±ï¸ ç‚¹å‡»äº†æ·»åŠ æ³¨é‡Šèœå•é¡¹ï¼Œè¡Œå·:', lineNumber);
                e.stopPropagation();
                e.preventDefault();
                closeContextMenu();
                // å»¶è¿Ÿæ‰§è¡Œï¼Œç¡®ä¿èœå•å…ˆå…³é—­
                setTimeout(() => {
                    console.log('â° å‡†å¤‡è°ƒç”¨ addOrEditCommentï¼Œè¡Œå·:', lineNumber);
                    addOrEditComment(lineNumber);
                }, 100);
            };
            menu.appendChild(commentItem);
            
            // å¦‚æœå·²æœ‰æ³¨é‡Šï¼Œæ˜¾ç¤ºåˆ é™¤æ³¨é‡Šé€‰é¡¹
            if (hasComment) {
                const deleteCommentItem = document.createElement('div');
                deleteCommentItem.className = 'context-menu-item';
                deleteCommentItem.innerHTML = '<span>ğŸ—‘ï¸</span><span>åˆ é™¤æ³¨é‡Š</span>';
                deleteCommentItem.onclick = (e) => {
                    e.stopPropagation();
                    deleteComment(lineNumber);
                    closeContextMenu();
                };
                menu.appendChild(deleteCommentItem);
            }
            
            // åˆ†éš”çº¿
            const separator3 = document.createElement('div');
            separator3.className = 'context-menu-separator';
            menu.appendChild(separator3);
            
            // å®šä½åˆ°æ­¤è¡Œ
            const jumpItem = document.createElement('div');
            jumpItem.className = 'context-menu-item';
            jumpItem.innerHTML = '<span>ğŸ¯</span><span>å®šä½åˆ°ç¬¬ ' + lineNumber + ' è¡Œ</span>';
            jumpItem.onclick = (e) => {
                e.stopPropagation();
                jumpToLine(lineNumber);
                closeContextMenu();
            };
            menu.appendChild(jumpItem);
            
            // è®¾ç½®ä½ç½®
            menu.style.left = event.pageX + 'px';
            menu.style.top = event.pageY + 'px';
            
            document.body.appendChild(menu);
            currentContextMenu = menu;
            
            // ç‚¹å‡»å…¶ä»–åœ°æ–¹å…³é—­èœå•
            setTimeout(() => {
                document.addEventListener('click', closeContextMenu);
            }, 0);
        }
        
        function closeContextMenu() {
            if (currentContextMenu) {
                document.body.removeChild(currentContextMenu);
                currentContextMenu = null;
            }
            document.removeEventListener('click', closeContextMenu);
        }
        
        function copyToClipboard(text) {
            // ä½¿ç”¨ Clipboard API
            navigator.clipboard.writeText(text).then(() => {
                // æ˜¾ç¤ºå¤åˆ¶æˆåŠŸæç¤º
                showCopyToast();
            }).catch(err => {
                console.error('å¤åˆ¶å¤±è´¥:', err);
            });
        }
        
        function showCopyToast() {
            const toast = document.createElement('div');
            toast.textContent = 'âœ… å·²å¤åˆ¶åˆ°å‰ªè´´æ¿';
            toast.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background-color: #10b981;
                color: white;
                padding: 10px 20px;
                border-radius: 5px;
                font-weight: bold;
                z-index: 10000;
                animation: fadeInOut 2s ease-in-out;
            `;
            document.body.appendChild(toast);
            
            setTimeout(() => {
                document.body.removeChild(toast);
            }, 2000);
        }
        
        // ========== é«˜çº§æœç´¢ ==========
        function showAdvancedSearchModal() {
            document.getElementById('advancedSearchModal').style.display = 'block';
        }
        
        function closeAdvancedSearchModal() {
            document.getElementById('advancedSearchModal').style.display = 'none';
        }
        
        function confirmAdvancedSearch() {
            const keyword = document.getElementById('advSearchKeyword').value.trim();
            const startTime = document.getElementById('advSearchStartTime').value.trim();
            const endTime = document.getElementById('advSearchEndTime').value.trim();
            
            const levels = [];
            if (document.getElementById('advSearchError').checked) levels.push('ERROR');
            if (document.getElementById('advSearchWarn').checked) levels.push('WARN');
            if (document.getElementById('advSearchInfo').checked) levels.push('INFO');
            if (document.getElementById('advSearchDebug').checked) levels.push('DEBUG');
            if (document.getElementById('advSearchOther').checked) levels.push('OTHER');
            
            console.log('ğŸ” é«˜çº§æœç´¢:', { keyword, startTime, endTime, levels });
            
            // åœ¨å·²åŠ è½½çš„æ•°æ®ä¸­è¿›è¡Œè¿‡æ»¤
            let results = [...allLines];
            
            // è¿‡æ»¤å…³é”®è¯
            if (keyword) {
                results = results.filter(line => {
                    const content = line.content || line;
                    return content.includes(keyword);
                });
            }
            
            // è¿‡æ»¤æ—¶é—´èŒƒå›´
            if (startTime || endTime) {
                results = results.filter(line => {
                    if (!line.timestamp) return false;
                    const lineTime = new Date(line.timestamp);
                    
                    if (startTime) {
                        const start = new Date(startTime);
                        if (lineTime < start) return false;
                    }
                    
                    if (endTime) {
                        const end = new Date(endTime);
                        if (lineTime > end) return false;
                    }
                    
                    return true;
                });
            }
            
            // è¿‡æ»¤çº§åˆ«
            if (levels.length > 0 && levels.length < 5) {
                results = results.filter(line => {
                    const level = line.level ? line.level.toUpperCase() : 'OTHER';
                    return levels.includes(level);
                });
            }
            
            console.log('âœ… æœç´¢ç»“æœ:', results.length, 'æ¡');
            
            allLines = results;
            currentPage = 1;
            isFiltering = true;
            updatePagination();
            renderLines();
            
            closeAdvancedSearchModal();
            
            if (results.length === 0) {
                alert('æœªæ‰¾åˆ°ç¬¦åˆæ¡ä»¶çš„æ—¥å¿—ï¼');
            }
        }
        
        
        // ========== æ—¶é—´çº¿åŠŸèƒ½ ==========
        function toggleTimeline() {
            isTimelineExpanded = !isTimelineExpanded;
            const content = document.getElementById('timelineContent');
            const icon = document.getElementById('timelineToggleIcon');
            
            if (isTimelineExpanded) {
                content.style.display = 'block';
                icon.textContent = 'â–¼';
            } else {
                content.style.display = 'none';
                icon.textContent = 'â–¶';
            }
        }
        
        function generateTimeline() {
            // æå–æ‰€æœ‰å¸¦æ—¶é—´æˆ³çš„æ—¥å¿—
            const logsWithTime = allLines.filter(line => line.timestamp);
            
            if (logsWithTime.length === 0) {
                document.getElementById('timelinePanel').style.display = 'none';
                return;
            }
            
            // æ˜¾ç¤ºæ—¶é—´çº¿é¢æ¿
            document.getElementById('timelinePanel').style.display = 'block';
            
            // è·å–æ—¶é—´èŒƒå›´
            const timestamps = logsWithTime.map(line => new Date(line.timestamp).getTime());
            const minTime = Math.min(...timestamps);
            const maxTime = Math.max(...timestamps);
            const timeRange = maxTime - minTime;
            
            // åˆ†æˆ20ä¸ªæ—¶é—´æ®µ
            const bucketCount = 20;
            const bucketSize = timeRange / bucketCount;
            const buckets = new Array(bucketCount).fill(0).map(() => ({
                count: 0,
                error: 0,
                warn: 0,
                info: 0,
                debug: 0,
                lines: []
            }));
            
            // ç»Ÿè®¡æ¯ä¸ªæ—¶é—´æ®µçš„æ—¥å¿—æ•°é‡
            logsWithTime.forEach(line => {
                const time = new Date(line.timestamp).getTime();
                const bucketIndex = Math.min(Math.floor((time - minTime) / bucketSize), bucketCount - 1);
                
                buckets[bucketIndex].count++;
                buckets[bucketIndex].lines.push(line);
                
                const level = (line.level || 'OTHER').toUpperCase();
                if (level === 'ERROR') buckets[bucketIndex].error++;
                else if (level === 'WARN') buckets[bucketIndex].warn++;
                else if (level === 'INFO') buckets[bucketIndex].info++;
                else if (level === 'DEBUG') buckets[bucketIndex].debug++;
            });
            
            timelineData = {
                buckets,
                minTime,
                maxTime,
                bucketSize
            };
            
            // ç»˜åˆ¶æ—¶é—´çº¿
            drawTimeline();
            
            // æ˜¾ç¤ºæ—¶é—´èŒƒå›´
            const startDate = new Date(minTime);
            const endDate = new Date(maxTime);
            const info = document.getElementById('timelineInfo');
            info.innerHTML = `<span>æ—¶é—´èŒƒå›´: ${formatDate(startDate)} è‡³ ${formatDate(endDate)}</span> <span style="margin-left: 20px;">æ€»è®¡: ${logsWithTime.length} æ¡æ—¥å¿—</span>`;
        }
        
        function drawTimeline() {
            if (!timelineData) return;
            
            const canvas = document.getElementById('timelineCanvas');
            const ctx = canvas.getContext('2d');
            
            // è®¾ç½®ç”»å¸ƒå¤§å°
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = 80;
            
            // æ¸…ç©ºç”»å¸ƒ
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const { buckets } = timelineData;
            const maxCount = Math.max(...buckets.map(b => b.count));
            
            const barWidth = canvas.width / buckets.length;
            const maxHeight = canvas.height - 20;
            
            // ç»˜åˆ¶æŸ±çŠ¶å›¾
            buckets.forEach((bucket, i) => {
                const x = i * barWidth;
                const heightRatio = bucket.count / maxCount;
                
                // ç»˜åˆ¶åˆ†å±‚æŸ±çŠ¶å›¾ï¼ˆæŒ‰çº§åˆ«ï¼‰
                let currentY = canvas.height - 20;
                
                // ERROR (çº¢è‰²)
                if (bucket.error > 0) {
                    const h = (bucket.error / bucket.count) * heightRatio * maxHeight;
                    ctx.fillStyle = '#f14c4c';
                    ctx.fillRect(x + 1, currentY - h, barWidth - 2, h);
                    currentY -= h;
                }
                
                // WARN (æ©™è‰²)
                if (bucket.warn > 0) {
                    const h = (bucket.warn / bucket.count) * heightRatio * maxHeight;
                    ctx.fillStyle = '#cca700';
                    ctx.fillRect(x + 1, currentY - h, barWidth - 2, h);
                    currentY -= h;
                }
                
                // INFO (è“è‰²)
                if (bucket.info > 0) {
                    const h = (bucket.info / bucket.count) * heightRatio * maxHeight;
                    ctx.fillStyle = '#4fc1ff';
                    ctx.fillRect(x + 1, currentY - h, barWidth - 2, h);
                    currentY -= h;
                }
                
                // DEBUG (ç´«è‰²)
                if (bucket.debug > 0) {
                    const h = (bucket.debug / bucket.count) * heightRatio * maxHeight;
                    ctx.fillStyle = '#b267e6';
                    ctx.fillRect(x + 1, currentY - h, barWidth - 2, h);
                }
            });
            
            // æ·»åŠ ç‚¹å‡»äº‹ä»¶
            canvas.onclick = (e) => {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const bucketIndex = Math.floor(x / barWidth);
                
                if (bucketIndex >= 0 && bucketIndex < buckets.length) {
                    const bucket = buckets[bucketIndex];
                    if (bucket.lines.length > 0) {
                        // è·³è½¬åˆ°è¯¥æ—¶é—´æ®µçš„ç¬¬ä¸€æ¡æ—¥å¿—
                        const targetLine = bucket.lines[0];
                        jumpToLine(targetLine.lineNumber);
                    }
                }
            };
            
            // æ·»åŠ é¼ æ ‡æ‚¬åœæç¤º
            canvas.onmousemove = (e) => {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const bucketIndex = Math.floor(x / barWidth);
                
                if (bucketIndex >= 0 && bucketIndex < buckets.length) {
                    const bucket = buckets[bucketIndex];
                    const startTime = new Date(timelineData.minTime + bucketIndex * timelineData.bucketSize);
                    canvas.title = `${formatTime(startTime)}\næ€»è®¡: ${bucket.count} æ¡\nERROR: ${bucket.error} | WARN: ${bucket.warn} | INFO: ${bucket.info} | DEBUG: ${bucket.debug}`;
                }
            };
        }
        
        function formatDate(date) {
            return date.toLocaleString('zh-CN', { 
                year: 'numeric', 
                month: '2-digit', 
                day: '2-digit', 
                hour: '2-digit', 
                minute: '2-digit' 
            });
        }
        
        function formatTime(date) {
            return date.toLocaleString('zh-CN', { 
                hour: '2-digit', 
                minute: '2-digit',
                second: '2-digit'
            });
        }
        
        // æŒ‰ç±»åç­›é€‰
        function filterByClassName(className) {
            console.log('ğŸ” æŒ‰ç±»åç­›é€‰:', className);
            closeStatsModal();
            
            // ä¿å­˜ç­›é€‰å‰çš„ä½ç½®
            savePositionBeforeFilter();
            
            // è®°å½•ç­›é€‰çŠ¶æ€
            currentFilterType = 'class';
            currentFilterValue = className;
            showFilterStatus(`ç±»å: ${className}`);
            
            // ä½¿ç”¨æ­£åˆ™æœç´¢
            vscode.postMessage({
                command: 'regexSearch',
                pattern: className.replace(/\./g, '\\.'),  // è½¬ä¹‰ç‚¹å·
                flags: 'i'
            });
        }
        
        // æŒ‰æ–¹æ³•åç­›é€‰
        function filterByMethodName(methodName) {
            console.log('ğŸ”§ æŒ‰æ–¹æ³•åç­›é€‰:', methodName);
            closeStatsModal();
            
            // ä¿å­˜ç­›é€‰å‰çš„ä½ç½®
            savePositionBeforeFilter();
            
            // è®°å½•ç­›é€‰çŠ¶æ€
            currentFilterType = 'method';
            currentFilterValue = methodName;
            showFilterStatus(`æ–¹æ³•å: ${methodName}`);
            
            // æœç´¢ [methodName:xxx]
            vscode.postMessage({
                command: 'regexSearch',
                pattern: `\\[${methodName}:\\d+\\]`,
                flags: 'i'
            });
        }
        
        // æŒ‰çº¿ç¨‹åç­›é€‰
        function filterByThreadName(threadName) {
            console.log('ğŸ§µ æŒ‰çº¿ç¨‹åç­›é€‰:', threadName);
            closeStatsModal();
            
            // ä¿å­˜ç­›é€‰å‰çš„ä½ç½®
            savePositionBeforeFilter();
            
            // è®°å½•ç­›é€‰çŠ¶æ€
            currentFilterType = 'thread';
            currentFilterValue = threadName;
            showFilterStatus(`çº¿ç¨‹å: ${threadName}`);
            
            // æœç´¢ [çº¿ç¨‹å]
            vscode.postMessage({
                command: 'regexSearch',
                pattern: `\\[${threadName}\\]`,
                flags: 'i'
            });
        }
        
        // ä¿å­˜ç­›é€‰å‰çš„ä½ç½®
        function savePositionBeforeFilter() {
            savedPageBeforeFilter = currentPage;
            
            // ä¿å­˜å½“å‰é¡µç¬¬ä¸€è¡Œçš„è¡Œå·
            if (allLines.length > 0) {
                const startIndex = (currentPage - 1) * pageSize;
                if (startIndex < allLines.length) {
                    savedFirstLineBeforeFilter = allLines[startIndex].lineNumber || (startIndex + 1);
                }
            }
            
            console.log('ğŸ“Œ ä¿å­˜ç­›é€‰å‰ä½ç½® - é¡µç :', savedPageBeforeFilter, ', è¡Œå·:', savedFirstLineBeforeFilter);
        }
        
        // æ˜¾ç¤ºç­›é€‰çŠ¶æ€
        function showFilterStatus(text) {
            const panel = document.getElementById('filterStatusPanel');
            const statusText = document.getElementById('filterStatusText');
            statusText.textContent = text;
            panel.style.display = 'flex';
        }
        
        // éšè—ç­›é€‰çŠ¶æ€
        function hideFilterStatus() {
            const panel = document.getElementById('filterStatusPanel');
            panel.style.display = 'none';
        }
        
        // æ¸…é™¤è‡ªå®šä¹‰ç­›é€‰
        function clearCustomFilter() {
            console.log('âŒ æ¸…é™¤ç­›é€‰');
            currentFilterType = null;
            currentFilterValue = null;
            hideFilterStatus();
            
            // è¯·æ±‚åç«¯é‡æ–°åŠ è½½å®Œæ•´æ—¥å¿—ï¼Œå¹¶è·³è½¬åˆ°ä¿å­˜çš„ä½ç½®
            console.log('ğŸ”™ æ¢å¤åˆ°ç­›é€‰å‰ä½ç½® - è¡Œå·:', savedFirstLineBeforeFilter);
            
            if (savedFirstLineBeforeFilter) {
                // æœ‰ä¿å­˜çš„è¡Œå·ï¼Œè·³è½¬åˆ°é‚£è¡Œ
                vscode.postMessage({
                    command: 'jumpToLineInFullLog',
                    lineNumber: savedFirstLineBeforeFilter
                });
                
                // é‡ç½®ä¿å­˜çš„ä½ç½®
                savedPageBeforeFilter = 1;
                savedFirstLineBeforeFilter = null;
            } else {
                // æ²¡æœ‰ä¿å­˜çš„ä½ç½®ï¼Œä½¿ç”¨é»˜è®¤çš„åˆ·æ–°
                refresh();
            }
        }
        
        function showDeleteByTimeDialog() {
            document.getElementById('deleteByTimeModal').style.display = 'block';
        }
        
        function closeDeleteByTimeModal() {
            document.getElementById('deleteByTimeModal').style.display = 'none';
            document.getElementById('deleteTimeInput').value = '';
        }
        
        // ========== åˆ é™¤æ–¹å¼é€‰æ‹© ==========
        function showDeleteModal() {
            document.getElementById('deleteModal').style.display = 'block';
        }
        
        function closeDeleteModal() {
            document.getElementById('deleteModal').style.display = 'none';
        }
        
        function selectDeleteByTime() {
            closeDeleteModal();
            showDeleteByTimeDialog();
        }
        
        function selectDeleteByLine() {
            closeDeleteModal();
            showDeleteByLineDialog();
        }
        
        function confirmDeleteByTime() {
            const timeStr = document.getElementById('deleteTimeInput').value.trim();
            const mode = document.getElementById('deleteTimeMode').value;
            
            if (!timeStr) {
                alert('è¯·è¾“å…¥æ—¶é—´ï¼');
                return;
            }
            
            // ç®€å•éªŒè¯æ—¶é—´æ ¼å¼
            if (!/^\d{4}-\d{2}-\d{2}/.test(timeStr)) {
                alert('æ—¶é—´æ ¼å¼ä¸æ­£ç¡®ï¼è¯·ä½¿ç”¨æ ¼å¼ï¼š2024-01-01 12:00:00 æˆ– 2024-01-01');
                return;
            }
            
            vscode.postMessage({
                command: 'deleteByTime',
                timeStr: timeStr,
                mode: mode
            });
            
            closeDeleteByTimeModal();
        }
        
        function showDeleteByLineDialog() {
            document.getElementById('deleteByLineModal').style.display = 'block';
        }
        
        function closeDeleteByLineModal() {
            document.getElementById('deleteByLineModal').style.display = 'none';
            document.getElementById('deleteLineInput').value = '';
        }
        
        function showJumpDialog() {
            document.getElementById('jumpModal').style.display = 'block';
            document.getElementById('jumpLineInput').focus();
        }
        
        function closeJumpModal() {
            document.getElementById('jumpModal').style.display = 'none';
            document.getElementById('jumpLineInput').value = '';
            document.getElementById('jumpTimeInput').value = '';
        }
        
        function switchJumpMode() {
            const mode = document.getElementById('jumpMode').value;
            const lineSection = document.getElementById('jumpByLineSection');
            const timeSection = document.getElementById('jumpByTimeSection');
            
            if (mode === 'line') {
                lineSection.style.display = 'block';
                timeSection.style.display = 'none';
                document.getElementById('jumpLineInput').focus();
            } else {
                lineSection.style.display = 'none';
                timeSection.style.display = 'block';
                document.getElementById('jumpTimeInput').focus();
            }
        }
        
        function confirmJump() {
            const mode = document.getElementById('jumpMode').value;
            
            if (mode === 'line') {
                const lineNumber = parseInt(document.getElementById('jumpLineInput').value);
                if (!lineNumber || lineNumber < 1) {
                    alert('è¯·è¾“å…¥æœ‰æ•ˆçš„è¡Œå·ï¼ˆå¤§äº0çš„æ•´æ•°ï¼‰ï¼');
                    return;
                }
                if (lineNumber > allLines.length) {
                    alert(`è¡Œå·è¶…å‡ºèŒƒå›´ï¼å½“å‰æ€»è¡Œæ•°ï¼š${allLines.length}`);
                    return;
                }
                jumpToLine(lineNumber);
            } else {
                const timeStr = document.getElementById('jumpTimeInput').value.trim();
                if (!timeStr) {
                    alert('è¯·è¾“å…¥æ—¶é—´ï¼');
                    return;
                }
                if (!/^\d{4}-\d{2}-\d{2}/.test(timeStr)) {
                    alert('æ—¶é—´æ ¼å¼ä¸æ­£ç¡®ï¼è¯·ä½¿ç”¨æ ¼å¼ï¼š2024-01-01 12:00:00 æˆ– 2024-01-01');
                    return;
                }
                jumpToTime(timeStr);
            }
            
            closeJumpModal();
        }
        
        function jumpToLine(lineNumber) {
            console.log('ğŸ¯ å®šä½åˆ°è¡Œå·:', lineNumber);
            
            // åœ¨æŠ˜å æ¨¡å¼ä¸‹ï¼Œéœ€è¦æ™ºèƒ½æŸ¥æ‰¾ç›®æ ‡é¡µ
            if (isCollapseMode && pageRanges.size > 0) {
                console.log('ğŸ“ æŠ˜å æ¨¡å¼ - æ™ºèƒ½æŸ¥æ‰¾ç›®æ ‡é¡µ');
                
                // å…ˆå°è¯•åœ¨å·²è®¡ç®—çš„é¡µé¢ä¸­æŸ¥æ‰¾
                for (let [pageNum, range] of pageRanges.entries()) {
                    // æŸ¥æ‰¾è¯¥é¡µèŒƒå›´å†…çš„æ—¥å¿—æ˜¯å¦åŒ…å«ç›®æ ‡è¡Œå·
                    const pageLines = allLines.slice(range.start, range.end);
                    const hasTargetLine = pageLines.some(line => {
                        const actualLineNumber = line.lineNumber || 0;
                        return actualLineNumber === lineNumber;
                    });
                    
                    if (hasTargetLine) {
                        console.log(`âœ… åœ¨ç¬¬ ${pageNum} é¡µæ‰¾åˆ°ç›®æ ‡è¡Œ`);
                        currentPage = pageNum;
                        updatePagination();
                        renderLines();
                        
                        // ç­‰å¾…æ¸²æŸ“å®Œæˆåé«˜äº®ç›®æ ‡è¡Œ
                        setTimeout(() => {
                            highlightTargetLine(lineNumber);
                        }, 100);
                        return;
                    }
                }
                
                // å¦‚æœåœ¨å·²è®¡ç®—çš„é¡µé¢ä¸­æ²¡æ‰¾åˆ°ï¼Œå°è¯•ä¼°ç®—é¡µç 
                console.log('âš ï¸ å·²è®¡ç®—é¡µé¢ä¸­æœªæ‰¾åˆ°ï¼Œä½¿ç”¨ä¼°ç®—æ–¹æ³•');
                const estimatedPage = Math.ceil(lineNumber / pageSize);
                currentPage = Math.max(1, Math.min(estimatedPage, totalPages));
            } else {
                // éæŠ˜å æ¨¡å¼æˆ–æœªè®¡ç®—é¡µé¢ï¼Œä½¿ç”¨æ ‡å‡†è®¡ç®—
                const targetPage = Math.ceil(lineNumber / pageSize);
                currentPage = targetPage;
            }
            
            updatePagination();
            renderLines();
            
            // ç­‰å¾…æ¸²æŸ“å®Œæˆåé«˜äº®ç›®æ ‡è¡Œ
            setTimeout(() => {
                highlightTargetLine(lineNumber);
            }, 100);
        }
        
        // ä»æœç´¢ç»“æœè·³è½¬åˆ°å®Œæ•´æ—¥å¿—çš„æŒ‡å®šè¡Œ
        function jumpToLineInFullLog(lineNumber) {
            console.log('ğŸš€ è·³è½¬åˆ°å®Œæ•´æ—¥å¿—çš„è¡Œ:', lineNumber);
            
            // æ¸…é™¤æœç´¢å…³é”®è¯å’Œè¿‡æ»¤çŠ¶æ€
            currentSearchKeyword = '';
            document.getElementById('searchInput').value = '';
            isFiltering = false;
            
            // æ˜¾ç¤ºåŠ è½½æç¤º
            showToast('ğŸ“¦ æ­£åœ¨åŠ è½½å®Œæ•´æ—¥å¿—...');
            
            // è¯·æ±‚åç«¯é‡æ–°åŠ è½½å®Œæ•´æ—¥å¿—ï¼Œå¹¶è·³è½¬åˆ°æŒ‡å®šè¡Œ
            vscode.postMessage({
                command: 'jumpToLineInFullLog',
                lineNumber: lineNumber
            });
        }
        
        function jumpToTime(timeStr) {
            console.log('ğŸ¯ å®šä½åˆ°æ—¶é—´:', timeStr);
            
            // ç›´æ¥è¯·æ±‚åç«¯æŸ¥æ‰¾
            vscode.postMessage({
                command: 'jumpToTime',
                timeStr: timeStr
            });
        }
        
        function handleJumpToTimeResult(data) {
            if (data.success) {
                console.log('âœ… æ‰¾åˆ°ç›®æ ‡æ—¶é—´çš„æ—¥å¿—ï¼Œè¡Œå·:', data.targetLineNumber);
                
                // åˆå¹¶æ–°åŠ è½½çš„æ•°æ®
                const newLines = data.lines;
                const startLine = data.startLine;
                
                // æ›´æ–° allLinesï¼šå¦‚æœæ–°æ•°æ®è¦†ç›–äº†å·²åŠ è½½çš„èŒƒå›´ï¼Œåˆ™åˆå¹¶
                if (allLines.length === 0 || startLine >= allLines.length) {
                    // æ–°æ•°æ®åœ¨å·²åŠ è½½æ•°æ®ä¹‹åï¼Œç›´æ¥è¿½åŠ 
                    allLines = allLines.concat(newLines);
                } else {
                    // æ›¿æ¢æˆ–æ’å…¥æ–°æ•°æ®
                    for (let i = 0; i < newLines.length; i++) {
                        const globalIndex = startLine + i;
                        if (globalIndex < allLines.length) {
                            allLines[globalIndex] = newLines[i];
                        } else {
                            allLines.push(newLines[i]);
                        }
                    }
                }
                
                // è·³è½¬åˆ°ç›®æ ‡è¡Œ
                jumpToLine(data.targetLineNumber);
            } else {
                console.error('âŒ æœªæ‰¾åˆ°ç›®æ ‡æ—¶é—´çš„æ—¥å¿—');
                alert(data.message || 'æœªæ‰¾åˆ°å¤§äºæˆ–ç­‰äºè¯¥æ—¶é—´çš„æ—¥å¿—ï¼');
            }
        }
        
        function highlightTargetLine(lineNumber) {
            console.log('ğŸ”† é«˜äº®ç›®æ ‡è¡Œ:', lineNumber);
            
            // ç§»é™¤ä¹‹å‰çš„é«˜äº®
            document.querySelectorAll('.log-line.highlight-target').forEach(el => {
                el.classList.remove('highlight-target');
            });
            
            // æŸ¥æ‰¾ç›®æ ‡è¡Œï¼ˆé€šè¿‡è¡Œå·åŒ¹é…ï¼Œè€Œä¸æ˜¯ç´¢å¼•ï¼‰
            const logLines = document.querySelectorAll('.log-line');
            
            for (let i = 0; i < logLines.length; i++) {
                const logLine = logLines[i];
                const lineNumberSpan = logLine.querySelector('.log-line-number');
                
                if (lineNumberSpan) {
                    // æå–è¡Œå·ï¼ˆå»é™¤ä¹¦ç­¾å›¾æ ‡ï¼‰
                    const displayedLineNumber = parseInt(lineNumberSpan.textContent.replace(/ğŸ“Œ\s*/, ''));
                    
                    if (displayedLineNumber === lineNumber) {
                        console.log(`âœ… æ‰¾åˆ°ç›®æ ‡è¡Œï¼Œç´¢å¼•: ${i}`);
                        logLine.classList.add('highlight-target');
                        
                        // æ»šåŠ¨åˆ°å¯è§åŒºåŸŸ
                        logLine.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        
                        // 3ç§’åç§»é™¤é«˜äº®
                        setTimeout(() => {
                            logLine.classList.remove('highlight-target');
                        }, 3000);
                        
                        return;
                    }
                }
            }
            
            console.log('âš ï¸ æœªæ‰¾åˆ°ç›®æ ‡è¡Œï¼Œå¯èƒ½ä¸åœ¨å½“å‰é¡µé¢');
        }
        
        function confirmDeleteByLine() {
            const lineNumber = parseInt(document.getElementById('deleteLineInput').value);
            const mode = document.getElementById('deleteLineMode').value;
            
            if (!lineNumber || lineNumber < 1) {
                alert('è¯·è¾“å…¥æœ‰æ•ˆçš„è¡Œå·ï¼ˆå¤§äº0çš„æ•´æ•°ï¼‰ï¼');
                return;
            }
            
            vscode.postMessage({
                command: 'deleteByLine',
                lineNumber: lineNumber,
                mode: mode
            });
            
            closeDeleteByLineModal();
        }
        
        function exportLogs() {
            vscode.postMessage({
                command: 'exportLogs',
                lines: allLines
            });
        }
        
        function refresh() {
            currentSearchKeyword = '';
            document.getElementById('searchInput').value = '';
            currentPage = 1;
            isFiltering = false; // é€€å‡ºè¿‡æ»¤æ¨¡å¼
            vscode.postMessage({
                command: 'refresh'
            });
        }
        
        // åˆ†é¡µåŠŸèƒ½
        function updatePagination() {
            let isEstimated = false; // æ ‡è®°æ€»é¡µæ•°æ˜¯å¦ä¸ºä¼°ç®—å€¼
            
            // åœ¨æŠ˜å æ¨¡å¼ä¸‹ï¼Œæ€»é¡µæ•°éš¾ä»¥ç²¾ç¡®è®¡ç®—ï¼Œéœ€è¦åŠ¨æ€ä¼°ç®—
            if (isCollapseMode) {
                // å¦‚æœå·²ç»æœ‰é¡µé¢èŒƒå›´è®°å½•ï¼Œæ ¹æ®æœ€åä¸€é¡µçš„ç»“æŸä½ç½®ä¼°ç®—
                if (pageRanges.size > 0) {
                    const maxPage = Math.max(...pageRanges.keys());
                    const maxRange = pageRanges.get(maxPage);
                    
                    if (maxRange.end >= allLines.length) {
                        // å·²ç»åˆ°è¾¾æœ€åï¼Œæ€»é¡µæ•°å°±æ˜¯å·²çŸ¥çš„æœ€å¤§é¡µ
                        totalPages = maxPage;
                        isEstimated = false; // ç²¾ç¡®å€¼
                    } else {
                        // è¿˜æœ‰æ›´å¤šæ•°æ®ï¼Œè‡³å°‘æ¯”å½“å‰å·²çŸ¥æœ€å¤§é¡µå¤š1é¡µï¼Œä»¥ä¾¿å¯ç”¨â€œä¸‹ä¸€é¡µâ€æŒ‰é’®
                        totalPages = maxPage + 1;
                        isEstimated = true; // ä¼°ç®—å€¼
                    }
                } else {
                    // æ²¡æœ‰è®°å½•ï¼Œä½¿ç”¨æ ‡å‡†è®¡ç®—ä½œä¸ºåˆå§‹ä¼°ç®—
                    totalPages = Math.ceil(allLines.length / pageSize);
                    isEstimated = true; // ä¼°ç®—å€¼
                }
            } else {
                // éæŠ˜å æ¨¡å¼ï¼Œä½¿ç”¨æ ‡å‡†è®¡ç®—
                totalPages = Math.ceil(allLines.length / pageSize);
                isEstimated = false;
            }
            
            if (totalPages < 1) totalPages = 1;
            if (currentPage > totalPages) currentPage = totalPages;
            
            document.getElementById('currentPageInput').value = currentPage;
            
            // æ˜¾ç¤ºæ€»é¡µæ•°ï¼šè®¡ç®—ä¸­ã€ä¼°ç®—å€¼æˆ–ç²¾ç¡®å€¼
            const totalPagesElement = document.getElementById('totalPages');
            if (isCalculatingPages) {
                // æ­£åœ¨è®¡ç®—ä¸­
                totalPagesElement.textContent = `è®¡ç®—ä¸­... ${calculationProgress}%`;
            } else if (isEstimated) {
                // ä¼°ç®—å€¼
                totalPagesElement.textContent = `â‰¥ ${totalPages - 1}`;
            } else {
                // ç²¾ç¡®å€¼
                totalPagesElement.textContent = totalPages;
            }
            
            document.getElementById('totalLinesInPage').textContent = allLines.length;
            
            // æ›´æ–°æŒ‰é’®çŠ¶æ€
            document.getElementById('firstPageBtn').disabled = currentPage === 1;
            document.getElementById('prevPageBtn').disabled = currentPage === 1;
            
            // åœ¨æŠ˜å æ¨¡å¼ä¸‹ï¼Œå¦‚æœæ˜¯ä¼°ç®—å€¼ï¼Œè¯´æ˜è¿˜æœ‰æ›´å¤šæ•°æ®ï¼Œä¸ç¦ç”¨â€œä¸‹ä¸€é¡µâ€æŒ‰é’®
            if (isCollapseMode && isEstimated) {
                document.getElementById('nextPageBtn').disabled = false;
                document.getElementById('lastPageBtn').disabled = false;
            } else {
                document.getElementById('nextPageBtn').disabled = currentPage === totalPages;
                document.getElementById('lastPageBtn').disabled = currentPage === totalPages;
            }
            
            // æ£€æŸ¥æ˜¯å¦éœ€è¦åŠ è½½æ›´å¤šæ•°æ®
            checkAndLoadMore();
        }
        
        function checkAndLoadMore() {
            // å¦‚æœå·²åŠ è½½å…¨éƒ¨æ•°æ®ï¼Œä¸å†åŠ è½½
            if (allDataLoaded) return;
            
            // å¦‚æœå¤„äºè¿‡æ»¤æ¨¡å¼ï¼Œä¸è‡ªåŠ¨åŠ è½½æ›´å¤šæ•°æ®
            if (isFiltering) {
                console.log('ğŸš« å¤„äºè¿‡æ»¤æ¨¡å¼ï¼Œä¸åŠ è½½æ›´å¤šæ•°æ®');
                return;
            }
            
            // å¦‚æœå½“å‰é¡µæ¥è¿‘å·²åŠ è½½æ•°æ®çš„æœ«å°¾ï¼Œè‡ªåŠ¨åŠ è½½æ›´å¤š
            const loadedLines = allLines.length;
            const currentMaxLine = currentPage * pageSize;
            
            if (currentMaxLine >= loadedLines - 500 && loadedLines < totalLinesInFile) {
                loadMoreData();
            }
        }
        
        function loadMoreData() {
            if (allDataLoaded) return;
            
            const currentLoaded = allLines.length;
            const remaining = totalLinesInFile - currentLoaded;
            const toLoad = Math.min(remaining, 10000); // æ¯æ¬¡åŠ è½½10000è¡Œ
            
            vscode.postMessage({
                command: 'loadMore',
                startLine: currentLoaded,
                count: toLoad
            });
        }
        
        function showLoadMoreHint() {
            // åœ¨é¡µé¢åº•éƒ¨æ˜¾ç¤ºåŠ è½½æ›´å¤šæŒ‰é’®
            const pagination = document.getElementById('pagination');
            let loadMoreBtn = document.getElementById('loadMoreBtn');
            
            if (!loadMoreBtn) {
                loadMoreBtn = document.createElement('button');
                loadMoreBtn.id = 'loadMoreBtn';
                loadMoreBtn.style.backgroundColor = '#0e7490';
                loadMoreBtn.style.marginLeft = '20px';
                loadMoreBtn.innerHTML = 'ğŸ“‚ åŠ è½½æ›´å¤šæ•°æ®';
                loadMoreBtn.onclick = function() {
                    loadAllRemainingData();
                };
                pagination.appendChild(loadMoreBtn);
            }
            
            loadMoreBtn.style.display = allDataLoaded ? 'none' : 'inline-block';
        }
        
        function loadAllRemainingData() {
            if (allDataLoaded) return;
            
            const remaining = totalLinesInFile - allLines.length;
            if (remaining <= 0) {
                allDataLoaded = true;
                return;
            }
            
            vscode.postMessage({
                command: 'loadMore',
                startLine: allLines.length,
                count: remaining
            });
            
            // éšè—åŠ è½½æŒ‰é’®
            const loadMoreBtn = document.getElementById('loadMoreBtn');
            if (loadMoreBtn) {
                loadMoreBtn.style.display = 'none';
            }
        }
        
        function goToFirstPage() {
            currentPage = 1;
            updatePagination();
            renderLines();
        }
        
        function goToPrevPage() {
            if (currentPage > 1) {
                currentPage--;
                updatePagination();
                renderLines();
                // ç¿»é¡µåè‡ªåŠ¨æ»šåŠ¨åˆ°é¡¶éƒ¨
                requestAnimationFrame(() => {
                    const logContainer = document.getElementById('logContainer');
                    if (logContainer) {
                        logContainer.scrollTop = 0;
                    }
                });
            }
        }
        
        function goToNextPage() {
            if (currentPage < totalPages) {
                currentPage++;
                updatePagination();
                renderLines();
                // ç¿»é¡µåè‡ªåŠ¨æ»šåŠ¨åˆ°é¡¶éƒ¨
                requestAnimationFrame(() => {
                    const logContainer = document.getElementById('logContainer');
                    if (logContainer) {
                        logContainer.scrollTop = 0;
                    }
                });
            }
        }
        
        function goToLastPage() {
            currentPage = totalPages;
            updatePagination();
            renderLines();
            // ç¿»é¡µåè‡ªåŠ¨æ»šåŠ¨åˆ°é¡¶éƒ¨
            requestAnimationFrame(() => {
                const logContainer = document.getElementById('logContainer');
                if (logContainer) {
                    logContainer.scrollTop = 0;
                }
            });
        }
        
        function goToPage(page) {
            page = parseInt(page);
            if (page >= 1 && page <= totalPages) {
                currentPage = page;
                
                // åœ¨æŠ˜å æ¨¡å¼ä¸‹ï¼Œå¦‚æœè·³è½¬åˆ°æœªè®¡ç®—è¿‡çš„é¡µé¢ï¼Œéœ€è¦å…ˆè®¡ç®—ä¸­é—´çš„æ‰€æœ‰é¡µé¢
                if (isCollapseMode && !pageRanges.has(page)) {
                    console.log(`ğŸ“– è·³è½¬åˆ°ç¬¬ ${page} é¡µï¼Œä½†è¯¥é¡µå°šæœªè®¡ç®—ï¼Œéœ€è¦ä»ç¬¬ 1 é¡µå¼€å§‹é¡ºåºè®¡ç®—`);
                    
                    // ä»ç¬¬ä¸€é¡µå¼€å§‹é¡ºåºè®¡ç®—åˆ°ç›®æ ‡é¡µ
                    pageRanges.clear();
                    for (let p = 1; p <= page; p++) {
                        currentPage = p;
                        // ä¸æ˜¾ç¤ºï¼Œåªè®¡ç®—èŒƒå›´
                        calculatePageRange(p);
                    }
                    
                    console.log(`âœ… å·²è®¡ç®—å®Œæˆï¼Œç¬¬ ${page} é¡µèŒƒå›´:`, pageRanges.get(page));
                }
                
                updatePagination();
                renderLines();
                // ç¿»é¡µåè‡ªåŠ¨æ»šåŠ¨åˆ°é¡¶éƒ¨
                console.log('ğŸ“ ç¿»é¡µåˆ°ç¬¬', currentPage, 'é¡µï¼Œå‡†å¤‡æ»šåŠ¨åˆ°é¡¶éƒ¨');
                requestAnimationFrame(() => {
                    const logContainer = document.getElementById('logContainer');
                    if (logContainer) {
                        console.log('ğŸ“ å½“å‰æ»šåŠ¨ä½ç½®:', logContainer.scrollTop);
                        logContainer.scrollTop = 0;
                        console.log('ğŸ“ æ»šåŠ¨åä½ç½®:', logContainer.scrollTop);
                    } else {
                        console.log('âš ï¸ æ‰¾ä¸åˆ° logContainer å…ƒç´ ');
                    }
                });
            } else {
                document.getElementById('currentPageInput').value = currentPage;
            }
        }
        
        function changePageSize(size) {
            pageSize = parseInt(size);
            currentPage = 1;
            pageRanges.clear(); // æ¸…ç©ºé¡µé¢èŒƒå›´è®°å½•ï¼Œé‡æ–°è®¡ç®—
            updatePagination();
            renderLines();
            // æ”¹å˜é¡µé¢å¤§å°åè‡ªåŠ¨æ»šåŠ¨åˆ°é¡¶éƒ¨
            requestAnimationFrame(() => {
                const logContainer = document.getElementById('logContainer');
                if (logContainer) {
                    logContainer.scrollTop = 0;
                }
            });
        }
        
        // ========== æ—¶é—´çº¿å¯¼èˆªåŠŸèƒ½ ==========
        
        function toggleTimeline() {
            isTimelineExpanded = !isTimelineExpanded;
            const content = document.getElementById('timelineContent');
            const icon = document.getElementById('timelineToggleIcon');
            
            if (isTimelineExpanded) {
                content.style.display = 'block';
                icon.textContent = 'â–¼';
            } else {
                content.style.display = 'none';
                icon.textContent = 'â–¶';
            }
        }
        
        function generateTimeline() {
            console.log('ğŸ“Š å¼€å§‹ç”Ÿæˆæ—¶é—´çº¿ï¼ŒallLines æ•°é‡:', allLines.length);
            
            // ä»allLinesä¸­æå–æ—¶é—´æˆ³
            const timestamps = [];
            const levelCounts = { ERROR: [], WARN: [], INFO: [], DEBUG: [], OTHER: [] };
            
            for (let line of allLines) {
                if (line.timestamp) {
                    timestamps.push(new Date(line.timestamp));
                }
            }
            
            console.log('ğŸ“Š æå–åˆ°çš„æ—¶é—´æˆ³æ•°é‡:', timestamps.length);
            
            // å¦‚æœæ²¡æœ‰æ—¶é—´æˆ³ï¼Œéšè—æ—¶é—´çº¿
            if (timestamps.length === 0) {
                console.log('âš ï¸ æ²¡æœ‰æ‰¾åˆ°æ—¶é—´æˆ³ï¼Œéšè—æ—¶é—´çº¿');
                document.getElementById('timelinePanel').style.display = 'none';
                return;
            }
            
            // æ‰¾å‡ºæ—¶é—´èŒƒå›´
            timestamps.sort((a, b) => a - b);
            const startTime = timestamps[0];
            const endTime = timestamps[timestamps.length - 1];
            const timeRange = endTime - startTime;
            
            console.log('ğŸ“Š æ—¶é—´èŒƒå›´:', startTime.toLocaleString(), '-', endTime.toLocaleString(), 'ï¼ŒèŒƒå›´:', timeRange, 'ms');
            
            // å¦‚æœæ—¶é—´èŒƒå›´å¤ªå°ï¼ˆæ¯”å¦‚éƒ½æ˜¯åŒä¸€ç§’ï¼‰ï¼Œä¸æ˜¾ç¤ºæ—¶é—´çº¿
            if (timeRange < 1000) { // å°äº1ç§’
                console.log('âš ï¸ æ—¶é—´èŒƒå›´å¤ªå°ï¼Œéšè—æ—¶é—´çº¿');
                document.getElementById('timelinePanel').style.display = 'none';
                return;
            }
            
            // å°†æ—¶é—´åˆ†æˆè‹¥å¹²ä¸ªæ¡¶ï¼ˆbucketï¼‰
            const bucketCount = 50; // æ—¶é—´çº¿åˆ†æˆ50æ®µ
            const bucketSize = timeRange / bucketCount;
            const buckets = new Array(bucketCount).fill(0);
            const bucketLevels = new Array(bucketCount).fill(null).map(() => ({ ERROR: 0, WARN: 0, INFO: 0, DEBUG: 0, OTHER: 0 }));
            
            // ç»Ÿè®¡æ¯ä¸ªæ¡¶çš„æ—¥å¿—æ•°é‡å’Œçº§åˆ«åˆ†å¸ƒ
            for (let line of allLines) {
                if (line.timestamp) {
                    const time = new Date(line.timestamp);
                    const bucketIndex = Math.min(Math.floor((time - startTime) / bucketSize), bucketCount - 1);
                    buckets[bucketIndex]++;
                    
                    const level = (line.level || 'OTHER').toUpperCase();
                    if (bucketLevels[bucketIndex][level] !== undefined) {
                        bucketLevels[bucketIndex][level]++;
                    } else {
                        bucketLevels[bucketIndex]['OTHER']++;
                    }
                }
            }
            
            // ä¿å­˜æ—¶é—´çº¿æ•°æ®
            timelineData = {
                startTime,
                endTime,
                timeRange,
                buckets,
                bucketLevels,
                bucketSize,
                bucketCount
            };
            
            console.log('âœ… æ—¶é—´çº¿æ•°æ®ç”Ÿæˆå®Œæˆï¼Œå‡†å¤‡ç»˜åˆ¶');
            
            // æ˜¾ç¤ºæ—¶é—´çº¿é¢æ¿
            document.getElementById('timelinePanel').style.display = 'block';
            
            // æ›´æ–°æ—¶é—´ä¿¡æ¯
            const info = document.getElementById('timelineInfo');
            info.innerHTML = `ğŸ“… ${startTime.toLocaleString()} â€” ${endTime.toLocaleString()} <span style="margin-left: 15px;">ğŸ“Š å…± ${timestamps.length} æ¡æœ‰æ—¶é—´æˆ³çš„æ—¥å¿—</span>`;
            
            // å»¶è¿Ÿç»˜åˆ¶ï¼Œç¡®ä¿Canvaså…ƒç´ å·²ç»æ¸²æŸ“å¥½
            setTimeout(() => {
                drawTimeline();
            }, 100);
        }
        
        function drawTimeline() {
            if (!timelineData) {
                console.log('âš ï¸ drawTimeline: timelineData ä¸ºç©º');
                return;
            }
            
            const canvas = document.getElementById('timelineCanvas');
            if (!canvas) {
                console.log('âš ï¸ drawTimeline: æ‰¾ä¸åˆ° canvas å…ƒç´ ');
                return;
            }
            
            const ctx = canvas.getContext('2d');
            if (!ctx) {
                console.log('âš ï¸ drawTimeline: æ— æ³•è·å– 2d context');
                return;
            }
            
            // è®¾ç½®canvaså®é™…å°ºå¯¸ï¼ˆé«˜åˆ†è¾¨ç‡ï¼‰
            const rect = canvas.getBoundingClientRect();
            
            // ç¡®ä¿canvasæœ‰æœ‰æ•ˆå°ºå¯¸
            if (rect.width === 0 || rect.height === 0) {
                console.log('âš ï¸ drawTimeline: canvas å°ºå¯¸ä¸º0ï¼Œç­‰å¾…æ¸²æŸ“...');
                // å†æ¬¡å»¶è¿Ÿå°è¯•
                setTimeout(() => drawTimeline(), 200);
                return;
            }
            
            console.log('ğŸ¨ å¼€å§‹ç»˜åˆ¶æ—¶é—´çº¿ï¼Œcanvas å°ºå¯¸:', rect.width, 'x', rect.height);
            
            canvas.width = rect.width * 2;
            canvas.height = 160;
            ctx.scale(2, 2);
            
            const width = rect.width;
            const height = 80;
            
            // æ¸…ç©ºç”»å¸ƒ
            ctx.clearRect(0, 0, width, height);
            
            // æ‰¾å‡ºæœ€å¤§å€¼ç”¨äºå½’ä¸€åŒ–
            const maxCount = Math.max(...timelineData.buckets, 1);
            
            // è®¡ç®—æ¯ä¸ªæŸ±å­çš„å®½åº¦
            const barWidth = width / timelineData.bucketCount;
            
            console.log('ğŸ¨ ç»˜åˆ¶å‚æ•° - æœ€å¤§å€¼:', maxCount, 'ï¼ŒæŸ±å®½:', barWidth);
            
            // ç»˜åˆ¶æŸ±çŠ¶å›¾
            for (let i = 0; i < timelineData.bucketCount; i++) {
                const count = timelineData.buckets[i];
                const barHeight = (count / maxCount) * (height - 10);
                const x = i * barWidth;
                const y = height - barHeight;
                
                // æ ¹æ®çº§åˆ«åˆ†å¸ƒå†³å®šé¢œè‰²
                const levels = timelineData.bucketLevels[i];
                let color = '#888888'; // é»˜è®¤ç°è‰²
                
                if (levels.ERROR > 0) {
                    color = '#f14c4c'; // çº¢è‰² - ERROR
                } else if (levels.WARN > 0) {
                    color = '#cca700'; // æ©™è‰² - WARN
                } else if (levels.INFO > 0) {
                    color = '#4fc1ff'; // è“è‰² - INFO
                } else if (levels.DEBUG > 0) {
                    color = '#b267e6'; // ç´«è‰² - DEBUG
                }
                
                // ç»˜åˆ¶æŸ±å­
                ctx.fillStyle = color;
                ctx.fillRect(x, y, Math.max(barWidth - 1, 1), barHeight);
            }
            
            console.log('âœ… æ—¶é—´çº¿ç»˜åˆ¶å®Œæˆ');
        }
        
        // ç‚¹å‡»æ—¶é—´çº¿è·³è½¬
        document.getElementById('timelineCanvas').addEventListener('click', function(e) {
            if (!timelineData) return;
            
            const canvas = this;
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const clickRatio = x / rect.width;
            
            // è®¡ç®—ç‚¹å‡»ä½ç½®å¯¹åº”çš„æ—¶é—´
            const targetTime = new Date(timelineData.startTime.getTime() + clickRatio * timelineData.timeRange);
            
            console.log('ğŸ• æ—¶é—´çº¿ç‚¹å‡» - ç›®æ ‡æ—¶é—´:', targetTime.toLocaleString());
            
            // åœ¨å·²åŠ è½½çš„æ•°æ®ä¸­æŸ¥æ‰¾æœ€æ¥è¿‘çš„è¡Œ
            let closestIndex = -1;
            let closestLineNumber = -1;
            let minDiff = Infinity;
            
            for (let i = 0; i < allLines.length; i++) {
                if (allLines[i].timestamp) {
                    const lineTime = new Date(allLines[i].timestamp);
                    const diff = Math.abs(lineTime - targetTime);
                    if (diff < minDiff) {
                        minDiff = diff;
                        closestIndex = i;
                        // è·å–å®é™…çš„è¡Œå·
                        closestLineNumber = allLines[i].lineNumber || (i + 1);
                    }
                }
            }
            
            if (closestIndex !== -1) {
                console.log(`ğŸ¯ æ‰¾åˆ°æœ€æ¥è¿‘çš„æ—¥å¿— - ç´¢å¼•:${closestIndex}, è¡Œå·:${closestLineNumber}`);
                
                // ä½¿ç”¨ jumpToLine å‡½æ•°è·³è½¬ï¼Œå®ƒèƒ½æ­£ç¡®å¤„ç†æŠ˜å æ¨¡å¼
                jumpToLine(closestLineNumber);
                
                showToast(`å·²è·³è½¬åˆ° ${new Date(allLines[closestIndex].timestamp).toLocaleString()}`);
            } else {
                showToast('âš ï¸ è¯¥æ—¶é—´æ®µæ²¡æœ‰æ—¥å¿—æ•°æ®');
            }
        });
        
        // é¼ æ ‡æ‚¬åœæ˜¾ç¤ºæ—¶é—´ä¿¡æ¯
        document.getElementById('timelineCanvas').addEventListener('mousemove', function(e) {
            if (!timelineData) return;
            
            const canvas = this;
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const hoverRatio = x / rect.width;
            
            // è®¡ç®—æ‚¬åœä½ç½®å¯¹åº”çš„æ—¶é—´
            const hoverTime = new Date(timelineData.startTime.getTime() + hoverRatio * timelineData.timeRange);
            
            // æ‰¾åˆ°å¯¹åº”çš„æ¡¶
            const bucketIndex = Math.min(Math.floor(hoverRatio * timelineData.bucketCount), timelineData.bucketCount - 1);
            const count = timelineData.buckets[bucketIndex];
            const levels = timelineData.bucketLevels[bucketIndex];
            
            // æ›´æ–°æ ‡é¢˜æ˜¾ç¤ºè¯¦ç»†ä¿¡æ¯
            canvas.title = `${hoverTime.toLocaleString()}\næ—¥å¿—æ•°: ${count}\nERROR: ${levels.ERROR} | WARN: ${levels.WARN} | INFO: ${levels.INFO} | DEBUG: ${levels.DEBUG}`;
        });
        
        // æœç´¢æ¡†å›è½¦æœç´¢
        document.getElementById('searchInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                search();
            }
        });
        
        // ========== JSON/XML è‡ªåŠ¨è§£æåŠŸèƒ½ ==========
        
        function detectAndParseStructuredData(content) {
            // å¦‚æœåŠŸèƒ½æœªå¯ç”¨ï¼Œç›´æ¥è¿”å›
            if (!enableJsonParse) return null;
            
            if (!content || typeof content !== 'string') return null;
            
            // æ”¹è¿›çš„JSONæ£€æµ‹ç­–ç•¥ï¼šä½¿ç”¨æ‹¬å·åŒ¹é…ç®—æ³•æå–å®Œæ•´JSON
            
            // å°è¯•åŒ¹é…JSONå¯¹è±¡ï¼ˆä½¿ç”¨æ‹¬å·åŒ¹é…ï¼‰
            const jsonObj = extractJSON(content, '{', '}');
            if (jsonObj) {
                try {
                    const parsed = JSON.parse(jsonObj);
                    // åªè§£æå¯¹è±¡ç±»å‹ï¼Œä¸”è‡³å°‘æœ‰ä¸€ä¸ªå±æ€§
                    if (typeof parsed === 'object' && parsed !== null && !Array.isArray(parsed) && Object.keys(parsed).length > 0) {
                        return renderJSONTree(parsed);
                    }
                } catch (e) {
                    console.debug('JSONå¯¹è±¡è§£æå¤±è´¥:', e.message);
                }
            }
            
            // å°è¯•åŒ¹é…JSONæ•°ç»„
            const jsonArr = extractJSON(content, '[', ']');
            if (jsonArr) {
                try {
                    const parsed = JSON.parse(jsonArr);
                    
                    if (Array.isArray(parsed)) {
                        // æ’é™¤ç®€å•çš„çº¯æ•°å­—æ•°ç»„ï¼ˆåªåŒ…å«ä¸€ä¸ªæ•°å­—ï¼‰
                        if (parsed.length === 1 && typeof parsed[0] === 'number') {
                            return null; // è·³è¿‡ [123]ã€[205] è¿™ç§æ ¼å¼
                        }
                        
                        // è§£æåŒ…å«å¯¹è±¡çš„æ•°ç»„ï¼Œæˆ–è€…åŒ…å«å¤šä¸ªå…ƒç´ çš„å¤æ‚æ•°ç»„
                        if (parsed.length > 0 && (typeof parsed[0] === 'object' || parsed.length > 3)) {
                            return renderJSONTree(parsed);
                        }
                    }
                } catch (e) {
                    console.debug('JSONæ•°ç»„è§£æå¤±è´¥:', e.message);
                }
            }
            
            // å°è¯•æ£€æµ‹XML
            const xmlMatch = content.match(/<[^>]+>[\s\S]*<\/[^>]+>/);
            if (xmlMatch) {
                try {
                    const xmlStr = xmlMatch[0];
                    return renderXMLTree(xmlStr);
                } catch (e) {
                    // ä¸æ˜¯æœ‰æ•ˆçš„XML
                }
            }
            
            return null;
        }
        
        // ä½¿ç”¨æ‹¬å·åŒ¹é…ç®—æ³•æå–å®Œæ•´çš„JSONå­—ç¬¦ä¸²
        function extractJSON(str, openChar, closeChar) {
            const startIndex = str.indexOf(openChar);
            if (startIndex === -1) return null;
            
            let depth = 0;
            let inString = false;
            let escapeNext = false;
            
            for (let i = startIndex; i < str.length; i++) {
                const char = str[i];
                
                // å¤„ç†è½¬ä¹‰å­—ç¬¦
                if (escapeNext) {
                    escapeNext = false;
                    continue;
                }
                
                if (char === '\\') {
                    escapeNext = true;
                    continue;
                }
                
                // å¤„ç†å­—ç¬¦ä¸²
                if (char === '"') {
                    inString = !inString;
                    continue;
                }
                
                // åœ¨å­—ç¬¦ä¸²å†…éƒ¨ï¼Œå¿½ç•¥æ‹¬å·
                if (inString) continue;
                
                // åŒ¹é…æ‹¬å·
                if (char === openChar) {
                    depth++;
                } else if (char === closeChar) {
                    depth--;
                    if (depth === 0) {
                        // æ‰¾åˆ°åŒ¹é…çš„é—­åˆæ‹¬å·
                        return str.substring(startIndex, i + 1);
                    }
                }
            }
            
            return null; // æ²¡æœ‰æ‰¾åˆ°åŒ¹é…çš„æ‹¬å·
        }
        
        function renderJSONTree(obj, depth = 0) {
            const id = 'json_' + Math.random().toString(36).substr(2, 9);
            
            if (obj === null) {
                return `<span class="json-null">null</span>`;
            }
            
            if (typeof obj === 'string') {
                return `<span class="json-string">"${escapeHtml(obj)}"</span>`;
            }
            
            if (typeof obj === 'number') {
                return `<span class="json-number">${obj}</span>`;
            }
            
            if (typeof obj === 'boolean') {
                return `<span class="json-boolean">${obj}</span>`;
            }
            
            const isArray = Array.isArray(obj);
            const keys = Object.keys(obj);
            const len = keys.length;
            
            if (len === 0) {
                return isArray ? '<span>[]</span>' : '<span>{}</span>';
            }
            
            // å¦‚æœå¯¹è±¡å¤ªå¤§ï¼Œé»˜è®¤æŠ˜å 
            const defaultCollapsed = depth > 0 || len > 10;
            
            // åªæœ‰ç¬¬ä¸€å±‚çº§æ·»åŠ  json-tree å®¹å™¨å’ŒæŠ˜å æ§ä»¶
            const isRootLevel = depth === 0;
            
            let html = '';
            
            if (isRootLevel) {
                html += '<div class="json-tree">';
                html += `<span class="json-tree-toggle" onclick="toggleJSONNode('${id}')">${defaultCollapsed ? 'â–¶' : 'â–¼'}</span>`;
                html += `<span>${isArray ? '[' : '{'}</span>`;
                html += `<span class="json-expand-btn" onclick="toggleJSONNode('${id}')" style="display:${defaultCollapsed ? 'inline-block' : 'none'}" id="${id}_btn">${len} items</span>`;
            } else {
                // å†…å±‚åµŒå¥—ä¸æ·»åŠ æŠ˜å æ§ä»¶ï¼Œç›´æ¥æ˜¾ç¤º
                html += `<span>${isArray ? '[' : '{'}</span>`;
            }
            
            html += `<div id="${id}" class="json-tree-item${defaultCollapsed ? ' json-tree-collapsed' : ''}">`;
            
            keys.forEach((key, index) => {
                const value = obj[key];
                const isLast = index === len - 1;
                
                html += '<div style="margin-left: 15px;">';
                
                if (!isArray) {
                    html += `<span class="json-key">"${escapeHtml(key)}"</span>: `;
                }
                
                if (typeof value === 'object' && value !== null) {
                    html += renderJSONTree(value, depth + 1);
                } else {
                    html += renderJSONTree(value, depth + 1);
                }
                
                if (!isLast) {
                    html += ',';
                }
                
                html += '</div>';
            });
            
            html += '</div>';
            html += `<span>${isArray ? ']' : '}'}</span>`;
            
            if (isRootLevel) {
                html += '</div>';
            }
            
            return html;
        }
        
        function renderXMLTree(xmlStr) {
            const id = 'xml_' + Math.random().toString(36).substr(2, 9);
            
            try {
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(xmlStr, 'text/xml');
                
                if (xmlDoc.getElementsByTagName('parsererror').length > 0) {
                    return null;
                }
                
                return renderXMLNode(xmlDoc.documentElement, 0);
            } catch (e) {
                return null;
            }
        }
        
        function renderXMLNode(node, depth = 0) {
            if (!node) return '';
            
            const id = 'xml_' + Math.random().toString(36).substr(2, 9);
            const tagName = node.tagName;
            const hasChildren = node.children.length > 0;
            const hasText = node.childNodes.length === 1 && node.childNodes[0].nodeType === 3;
            
            // é»˜è®¤æŠ˜å æ·±åº¦>1çš„èŠ‚ç‚¹
            const defaultCollapsed = depth > 1;
            
            let html = '<div class="xml-tree">';
            
            if (hasChildren) {
                html += `<span class="xml-tree-toggle" onclick="toggleXMLNode('${id}')">${defaultCollapsed ? 'â–¶' : 'â–¼'}</span>`;
            } else {
                html += '<span style="display:inline-block;width:14px;"></span>';
            }
            
            // å¼€å§‹æ ‡ç­¾
            html += '<span class="xml-tag">&lt;' + escapeHtml(tagName);
            
            // å±æ€§
            if (node.attributes) {
                for (let i = 0; i < node.attributes.length; i++) {
                    const attr = node.attributes[i];
                    html += ' <span class="xml-attr-name">' + escapeHtml(attr.name) + '</span>=';
                    html += '<span class="xml-attr-value">"' + escapeHtml(attr.value) + '"</span>';
                }
            }
            
            if (!hasChildren && !hasText) {
                html += '/&gt;</span>';
            } else {
                html += '&gt;</span>';
                
                if (hasText) {
                    html += escapeHtml(node.textContent.trim());
                } else if (hasChildren) {
                    html += `<div id="${id}" class="xml-tree-item${defaultCollapsed ? ' xml-tree-collapsed' : ''}">`;
                    
                    for (let i = 0; i < node.children.length; i++) {
                        html += renderXMLNode(node.children[i], depth + 1);
                    }
                    
                    html += '</div>';
                }
                
                html += '<span class="xml-tag">&lt;/' + escapeHtml(tagName) + '&gt;</span>';
            }
            
            html += '</div>';
            
            return html;
        }
        
        function toggleJSONNode(id) {
            const contentNode = document.getElementById(id);
            if (!contentNode) return;
            
            // å‘ä¸ŠæŸ¥æ‰¾ json-tree å®¹å™¨
            const container = contentNode.closest('.json-tree');
            if (!container) return;
            
            // æŸ¥æ‰¾ç®­å¤´å’Œå±•å¼€æŒ‰é’®
            const toggle = container.querySelector('.json-tree-toggle');
            const btn = document.getElementById(id + '_btn');
            
            if (contentNode.classList.contains('json-tree-collapsed')) {
                // å±•å¼€
                contentNode.classList.remove('json-tree-collapsed');
                if (toggle) toggle.textContent = 'â–¼';
                if (btn) btn.style.display = 'none';
            } else {
                // æŠ˜å 
                contentNode.classList.add('json-tree-collapsed');
                if (toggle) toggle.textContent = 'â–¶';
                if (btn) btn.style.display = 'inline-block';
            }
        }
        
        function toggleXMLNode(id) {
            const node = document.getElementById(id);
            const toggle = node.previousElementSibling.previousElementSibling;
            
            if (node.classList.contains('xml-tree-collapsed')) {
                node.classList.remove('xml-tree-collapsed');
                toggle.textContent = 'â–¼';
            } else {
                node.classList.add('xml-tree-collapsed');
                toggle.textContent = 'â–¶';
            }
        }
        
        // åˆ‡æ¢JSON/XMLè§£æåŠŸèƒ½
        function toggleJsonParse() {
            enableJsonParse = document.getElementById('enableJsonParse').checked;
            console.log('ğŸŒ² JSON/XMLè§£æåŠŸèƒ½:', enableJsonParse ? 'å·²å¯ç”¨' : 'å·²ç¦ç”¨');
            // é‡æ–°æ¸²æŸ“å½“å‰é¡µé¢
            renderLines();
        }
        
        // ========== è‡ªå®šä¹‰é«˜äº®è§„åˆ™ç®¡ç† ==========
        
        function showCustomHighlightModal() {
            renderHighlightRulesList();
            document.getElementById('customHighlightModal').style.display = 'block';
        }

        function closeCustomHighlightModal() {
            document.getElementById('customHighlightModal').style.display = 'none';
        }

        function showAddRuleDialog() {
            editingRuleIndex = -1;
            document.getElementById('ruleModalTitle').textContent = 'â• æ·»åŠ é«˜äº®è§„åˆ™';
            document.getElementById('ruleName').value = '';
            document.getElementById('ruleType').value = 'text';
            document.getElementById('rulePattern').value = '';
            document.getElementById('ruleBgColor').value = '#10b981';
            document.getElementById('ruleTextColor').value = '#ffffff';
            document.getElementById('ruleEnabled').checked = true;
            updateColorPreview();
            document.getElementById('addRuleModal').style.display = 'block';
        }

        function closeAddRuleModal() {
            document.getElementById('addRuleModal').style.display = 'none';
        }

        function saveHighlightRule() {
            const name = document.getElementById('ruleName').value.trim();
            const type = document.getElementById('ruleType').value;
            const pattern = document.getElementById('rulePattern').value.trim();
            const bgColor = document.getElementById('ruleBgColor').value;
            const textColor = document.getElementById('ruleTextColor').value;
            const enabled = document.getElementById('ruleEnabled').checked;
            
            if (!name) {
                showToast('âš ï¸ è¯·è¾“å…¥è§„åˆ™åç§°');
                document.getElementById('ruleName').focus();
                return;
            }
            
            if (!pattern) {
                showToast('âš ï¸ è¯·è¾“å…¥åŒ¹é…å†…å®¹');
                document.getElementById('rulePattern').focus();
                return;
            }
            
            // éªŒè¯æ­£åˆ™è¡¨è¾¾å¼
            if (type === 'regex') {
                try {
                    new RegExp(pattern);
                } catch (e) {
                    showToast('âŒ æ­£åˆ™è¡¨è¾¾å¼æ ¼å¼é”™è¯¯ï¼š' + e.message);
                    document.getElementById('rulePattern').focus();
                    return;
                }
            }
            
            const rule = {
                id: editingRuleIndex >= 0 ? customHighlightRules[editingRuleIndex].id : Date.now(),
                name,
                type,
                pattern,
                bgColor,
                textColor,
                enabled,
                builtin: false
            };
            
            if (editingRuleIndex >= 0) {
                // æ›´æ–°ç°æœ‰è§„åˆ™
                customHighlightRules[editingRuleIndex] = rule;
            } else {
                // æ·»åŠ æ–°è§„åˆ™
                customHighlightRules.push(rule);
            }
            
            saveCustomRulesToStorage();
            closeAddRuleModal();
            renderHighlightRulesList();
            renderLines(); // é‡æ–°æ¸²æŸ“æ—¥å¿—ä»¥åº”ç”¨æ–°è§„åˆ™
            showToast('âœ… è§„åˆ™å·²ä¿å­˜');
        }

        function editHighlightRule(index) {
            editingRuleIndex = index;
            const rule = customHighlightRules[index];
            
            document.getElementById('ruleModalTitle').textContent = 'âœï¸ ç¼–è¾‘é«˜äº®è§„åˆ™';
            document.getElementById('ruleName').value = rule.name;
            document.getElementById('ruleType').value = rule.type;
            document.getElementById('rulePattern').value = rule.pattern;
            document.getElementById('ruleBgColor').value = rule.bgColor;
            document.getElementById('ruleTextColor').value = rule.textColor;
            document.getElementById('ruleEnabled').checked = rule.enabled;
            updateColorPreview();
            document.getElementById('addRuleModal').style.display = 'block';
        }

        function toggleHighlightRule(index) {
            customHighlightRules[index].enabled = !customHighlightRules[index].enabled;
            saveCustomRulesToStorage();
            renderHighlightRulesList();
            renderLines(); // é‡æ–°æ¸²æŸ“æ—¥å¿—
        }

        function deleteHighlightRule(index) {
            console.log('ğŸ—‘ï¸ åˆ é™¤è§„åˆ™è¢«è°ƒç”¨, index:', index);
            console.log('å½“å‰è§„åˆ™æ•°é‡:', customHighlightRules.length);
            
            if (index < 0 || index >= customHighlightRules.length) {
                console.error('æ— æ•ˆçš„ç´¢å¼•:', index);
                showToast('âŒ è§„åˆ™ç´¢å¼•é”™è¯¯');
                return;
            }
            
            const rule = customHighlightRules[index];
            console.log('è¦åˆ é™¤çš„è§„åˆ™:', rule);
            
            if (rule.builtin) {
                showToast('âš ï¸ å†…ç½®è§„åˆ™ä¸èƒ½åˆ é™¤ï¼Œä½†å¯ä»¥ç¦ç”¨');
                return;
            }
            
            // ä½¿ç”¨è‡ªå®šä¹‰ç¡®è®¤å¯¹è¯æ¡†
            showCustomConfirm(`ç¡®å®šè¦åˆ é™¤è§„åˆ™ "${rule.name}" å—ï¼Ÿ`, 'åˆ é™¤è§„åˆ™').then(confirmed => {
                if (confirmed) {
                    console.log('ç”¨æˆ·ç¡®è®¤åˆ é™¤');
                    customHighlightRules.splice(index, 1);
                    console.log('åˆ é™¤åè§„åˆ™æ•°é‡:', customHighlightRules.length);
                    saveCustomRulesToStorage();
                    renderHighlightRulesList();
                    renderLines(); // é‡æ–°æ¸²æŸ“æ—¥å¿—
                    showToast('âœ… è§„åˆ™å·²åˆ é™¤');
                } else {
                    console.log('ç”¨æˆ·å–æ¶ˆåˆ é™¤');
                }
            });
        }

        function resetToDefault() {
            // ä½¿ç”¨è‡ªå®šä¹‰ç¡®è®¤å¯¹è¯æ¡†
            showCustomConfirm('ç¡®å®šè¦é‡ç½®æ‰€æœ‰è§„åˆ™åˆ°é»˜è®¤çŠ¶æ€å—ï¼Ÿè¿™å°†åˆ é™¤æ‰€æœ‰è‡ªå®šä¹‰è§„åˆ™ï¼', 'é‡ç½®è§„åˆ™').then(confirmed => {
                if (confirmed) {
                    // åªä¿ç•™å†…ç½®è§„åˆ™
                    customHighlightRules = customHighlightRules.filter(r => r.builtin);
                    // å¯ç”¨æ‰€æœ‰å†…ç½®è§„åˆ™
                    customHighlightRules.forEach(r => r.enabled = true);
                    localStorage.removeItem('customHighlightRules');
                    renderHighlightRulesList();
                    renderLines();
                    showToast('âœ… å·²é‡ç½®åˆ°é»˜è®¤è§„åˆ™');
                }
            });
        }

        function renderHighlightRulesList() {
            const container = document.getElementById('highlightRulesList');
            
            if (customHighlightRules.length === 0) {
                container.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--vscode-descriptionForeground);">æš‚æ— è§„åˆ™</div>';
                return;
            }
            
            // æ¸…ç©ºå®¹å™¨
            container.innerHTML = '';
            
            customHighlightRules.forEach((rule, index) => {
                const typeLabel = rule.type === 'text' ? 'æ–‡æœ¬' : 'æ­£åˆ™';
                const currentIndex = index; // ä¿å­˜å½“å‰ç´¢å¼•ï¼Œé¿å…é—­åŒ…é—®é¢˜
                
                // åˆ›å»ºè§„åˆ™é¡¹
                const ruleItem = document.createElement('div');
                ruleItem.className = 'rule-item';
                ruleItem.style.borderLeftColor = rule.bgColor;
                ruleItem.setAttribute('data-index', currentIndex); // æ·»åŠ æ•°æ®å±æ€§
                
                // å¤é€‰æ¡†
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.checked = rule.enabled;
                checkbox.style.cursor = 'pointer';
                checkbox.addEventListener('change', function() {
                    toggleHighlightRule(currentIndex);
                });
                
                // å†…å®¹åŒºåŸŸ
                const contentDiv = document.createElement('div');
                contentDiv.style.flex = '1';
                
                // è§„åˆ™åç§°è¡Œ
                const nameDiv = document.createElement('div');
                nameDiv.style.fontWeight = 'bold';
                nameDiv.style.marginBottom = '5px';
                nameDiv.textContent = rule.name + ' ';
                
                if (rule.builtin) {
                    const builtinTag = document.createElement('span');
                    builtinTag.style.cssText = 'background-color: #6366f1; color: white; font-size: 10px; padding: 2px 6px; border-radius: 3px; margin-left: 5px;';
                    builtinTag.textContent = 'å†…ç½®';
                    nameDiv.appendChild(builtinTag);
                }
                
                const typeTag = document.createElement('span');
                typeTag.style.cssText = 'background-color: var(--vscode-editorWidget-background); color: var(--vscode-descriptionForeground); font-size: 10px; padding: 2px 6px; border-radius: 3px; margin-left: 5px;';
                typeTag.textContent = typeLabel;
                nameDiv.appendChild(typeTag);
                
                // åŒ¹é…å†…å®¹è¡Œ
                const patternDiv = document.createElement('div');
                patternDiv.style.cssText = 'font-size: 11px; color: var(--vscode-descriptionForeground); font-family: "Consolas", monospace;';
                patternDiv.textContent = rule.pattern;
                
                // ç¤ºä¾‹æ•ˆæœ
                const exampleDiv = document.createElement('div');
                exampleDiv.style.marginTop = '5px';
                const exampleSpan = document.createElement('span');
                exampleSpan.className = 'custom-highlight';
                exampleSpan.style.cssText = `background-color: ${rule.bgColor}; color: ${rule.textColor}; font-size: 11px;`;
                exampleSpan.textContent = 'ç¤ºä¾‹æ•ˆæœ';
                exampleDiv.appendChild(exampleSpan);
                
                contentDiv.appendChild(nameDiv);
                contentDiv.appendChild(patternDiv);
                contentDiv.appendChild(exampleDiv);
                
                // æŒ‰é’®åŒºåŸŸ
                const buttonsDiv = document.createElement('div');
                buttonsDiv.style.display = 'flex';
                buttonsDiv.style.gap = '5px';
                
                if (!rule.builtin) {
                    // ç¼–è¾‘æŒ‰é’®
                    const editBtn = document.createElement('button');
                    editBtn.textContent = 'ç¼–è¾‘';
                    editBtn.style.cssText = 'padding: 5px 10px; font-size: 11px;';
                    editBtn.addEventListener('click', function() {
                        console.log('ğŸ“ ç¼–è¾‘æŒ‰é’®è¢«ç‚¹å‡», index:', currentIndex);
                        editHighlightRule(currentIndex);
                    });
                    
                    // åˆ é™¤æŒ‰é’®
                    const deleteBtn = document.createElement('button');
                    deleteBtn.textContent = 'åˆ é™¤';
                    deleteBtn.style.cssText = 'padding: 5px 10px; font-size: 11px;';
                    deleteBtn.addEventListener('click', function(e) {
                        console.log('ğŸ”´ åˆ é™¤æŒ‰é’®è¢«ç‚¹å‡», index:', currentIndex);
                        e.stopPropagation(); // é˜»æ­¢äº‹ä»¶å†’æ³¡
                        deleteHighlightRule(currentIndex);
                    });
                    
                    buttonsDiv.appendChild(editBtn);
                    buttonsDiv.appendChild(deleteBtn);
                }
                
                ruleItem.appendChild(checkbox);
                ruleItem.appendChild(contentDiv);
                ruleItem.appendChild(buttonsDiv);
                
                container.appendChild(ruleItem);
            });
            
            // é‡ç½®æŒ‰é’®
            const resetDiv = document.createElement('div');
            resetDiv.style.cssText = 'margin-top: 20px; text-align: center;';
            const resetBtn = document.createElement('button');
            resetBtn.textContent = 'ğŸ”„ é‡ç½®ä¸ºé»˜è®¤è§„åˆ™';
            resetBtn.addEventListener('click', resetToDefault);
            resetDiv.appendChild(resetBtn);
            
            container.appendChild(resetDiv);
        }

        function updateColorPreview() {
            const bgColor = document.getElementById('ruleBgColor').value;
            const textColor = document.getElementById('ruleTextColor').value;
            const preview = document.getElementById('colorPreview');
            if (preview) {
                preview.style.backgroundColor = bgColor;
                preview.style.color = textColor;
            }
        }
        
        // ========== ç»“æŸè‡ªå®šä¹‰é«˜äº®è§„åˆ™ç®¡ç† ==========
        
        // é”®ç›˜å¿«æ·é”®æ”¯æŒ
        document.addEventListener('keydown', function(e) {
            // ä¸åœ¨è¾“å…¥æ¡†ä¸­æ—¶æ‰å“åº”
            if (e.target.tagName === 'INPUT') return;
            
            if (e.key === 'ArrowLeft' || e.key === 'PageUp') {
                e.preventDefault();
                goToPrevPage();
            } else if (e.key === 'ArrowRight' || e.key === 'PageDown') {
                e.preventDefault();
                goToNextPage();
            } else if (e.key === 'Home') {
                e.preventDefault();
                goToFirstPage();
            } else if (e.key === 'End') {
                e.preventDefault();
                goToLastPage();
            }
        });
    </script>
</body>
</html>
