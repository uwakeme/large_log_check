# 基础搜索

<cite>
**本文档引用的文件**   
- [logProcessor.ts](file://src/logProcessor.ts)
- [logViewerPanel.ts](file://src/logViewerPanel.ts)
- [webview.html](file://src/webview.html)
</cite>

## 目录
1. [简介](#简介)
2. [核心搜索功能实现](#核心搜索功能实现)
3. [UI与前端实现](#ui与前端实现)
4. [搜索结果高亮机制](#搜索结果高亮机制)
5. [最佳实践与使用场景](#最佳实践与使用场景)

## 简介
`large_log_check` 是一个专为处理大型日志文件而设计的 VSCode 扩展。其核心功能之一是高效、低内存占用的关键词搜索。本文档将深入解析其基础搜索功能的实现，涵盖从后端 Node.js 流式处理到前端 UI 交互的完整流程。

## 核心搜索功能实现

`large_log_check` 的搜索功能核心在于 `logProcessor.ts` 文件中的 `search` 方法。该方法利用 Node.js 的流式读取能力，实现了对超大日志文件的高效搜索，避免了将整个文件加载到内存中导致的内存溢出问题。

`search` 方法接收一个 `keyword`（关键词）和一个可选的 `reverse`（反向搜索）参数。其核心实现逻辑如下：

1.  **流式读取**：方法使用 `fs.createReadStream` 创建一个文件读取流，并通过 `readline.createInterface` 将其包装成一个按行读取的接口。这使得程序可以逐行处理日志文件，而不是一次性加载整个文件。
2.  **正则表达式匹配**：为了实现不区分大小写的搜索，代码使用 `new RegExp(keyword, 'i')` 创建一个正则表达式对象。`'i'` 标志确保了匹配过程是大小写不敏感的。
3.  **逐行匹配**：通过监听 `rl.on('line')` 事件，程序对读取到的每一行内容执行 `searchRegex.test(line)` 检查。如果匹配成功，则将该行的行号、内容、时间戳和日志级别等信息封装成一个 `LogLine` 对象，并推入结果数组 `results` 中。
4.  **异步处理**：整个搜索过程是异步的，通过 `Promise` 包装。当流读取完成（`rl.on('close')`）时，Promise 被 resolve，返回所有匹配的结果。如果需要反向搜索，结果数组会在返回前被 `reverse()` 方法倒序。

这种流式处理方式使得搜索性能与文件大小呈线性关系，即使面对 GB 级别的日志文件，也能在合理时间内完成搜索，同时内存占用始终保持在较低水平。

**Section sources**
- [logProcessor.ts](file://src/logProcessor.ts#L135-L167)

## UI与前端实现

搜索功能的用户界面主要由 `webview.html` 文件定义，并通过 `logViewerPanel.ts` 中的 WebView 消息机制与后端进行通信。

### 搜索框UI实现
在 `webview.html` 的 HTML 结构中，搜索功能由一个包含输入框和多个按钮的工具栏（`.toolbar`）实现。核心元素是一个 `input[type="text"]`，其 `id` 为 `searchInput`，用于接收用户输入的关键词。旁边有“正则”和“反向搜索”两个复选框，以及一个“搜索”按钮。

```html
<div class="search-box">
    <input type="text" id="searchInput" placeholder="搜索日志内容...">
    <label style="font-size: 12px; display: flex; align-items: center; gap: 5px;">
        <input type="checkbox" id="regexMode">
        <span>正则</span>
    </label>
    <label style="font-size: 12px; display: flex; align-items: center; gap: 5px;">
        <input type="checkbox" id="reverseMode">
        <span>反向搜索</span>
    </label>
    <button onclick="search()">🔍 搜索</button>
    ...
</div>
```

### WebView消息机制
当用户点击“搜索”按钮时，会触发 `onclick="search()"` 事件，调用 JavaScript 中的 `search()` 函数。

`search()` 函数首先从 DOM 中获取用户输入的关键词和复选框状态。然后，它通过 `vscode.postMessage()` 方法向后端（即 `logViewerPanel.ts`）发送一个消息。消息的 `command` 字段为 `'search'`，并携带 `keyword` 和 `reverse` 参数。

```javascript
function search() {
    const keyword = document.getElementById('searchInput').value;
    const isReverse = document.getElementById('reverseMode').checked;
    
    if (!keyword) {
        // 处理空搜索
        return;
    }
    
    vscode.postMessage({
        command: 'search',
        keyword: keyword,
        reverse: isReverse
    });
}
```

在 `logViewerPanel.ts` 中，构造函数通过 `this._panel.webview.onDidReceiveMessage` 监听来自前端的消息。当收到 `command` 为 `'search'` 的消息时，它会调用 `this.searchLogs(message.keyword, message.reverse)` 方法。

`searchLogs` 方法是连接前端和后端的桥梁。它调用 `LogProcessor` 实例的 `search` 方法执行实际的搜索，并将搜索结果通过 `this._panel.webview.postMessage` 发送回前端，命令为 `'searchResults'`。

```typescript
private async searchLogs(keyword: string, reverse: boolean = false) {
    try {
        const results = await this._logProcessor.search(keyword, reverse);
        this._panel.webview.postMessage({
            command: 'searchResults',
            data: {
                keyword: keyword,
                results: results
            }
        });
    } catch (error) {
        vscode.window.showErrorMessage(`搜索失败: ${error}`);
    }
}
```

**Section sources**
- [webview.html](file://src/webview.html#L671-L680)
- [logViewerPanel.ts](file://src/logViewerPanel.ts#L165-L178)

## 搜索结果高亮机制

搜索结果的高亮显示是通过前端的 CSS 样式和 JavaScript 渲染逻辑共同实现的。

### 高亮样式定义
在 `webview.html` 的 `<style>` 标签中，定义了一个名为 `highlight` 的 CSS 类。该类设置了背景色和文字颜色，用于突出显示匹配的文本。

```css
.highlight {
    background-color: var(--vscode-editor-findMatchHighlightBackground);
    color: var(--vscode-editor-findMatchHighlightForeground);
    padding: 2px 4px;
    border-radius: 2px;
    font-weight: bold;
}
```

### 高亮渲染逻辑
当后端通过 `postMessage` 发送 `searchResults` 消息后，前端的 `handleSearchResults` 函数会被调用。该函数会更新全局变量 `allLines` 为搜索结果，并重新调用 `renderLines()` 函数来渲染日志。

`renderLines()` 函数负责将每一条日志渲染成 HTML 元素。在渲染单条日志的 `renderSingleLine` 函数中，会检查当前是否存在 `currentSearchKeyword`。如果存在，则使用 `highlightText` 函数对日志内容进行处理。

`highlightText` 函数的核心是使用 `String.prototype.replace()` 方法，配合一个动态创建的正则表达式（`new RegExp(escapeRegex(keyword), 'gi')`），将所有匹配的关键词替换为包裹在 `<span class="highlight">` 标签内的文本。

```javascript
function highlightText(text, keyword) {
    if (!keyword) return text;
    const escapedKeyword = escapeRegex(keyword);
    const regex = new RegExp(`(${escapedKeyword})`, 'gi');
    return text.replace(regex, '<span class="highlight">$1</span>');
}
```

最终，经过 `highlightText` 处理后的 HTML 字符串被插入到日志行的 DOM 元素中，从而实现了关键词的高亮显示。

**Section sources**
- [webview.html](file://src/webview.html#L115-L118)
- [webview.html](file://src/webview.html#L1256-L1263)
- [webview.html](file://src/webview.html#L1414)

## 最佳实践与使用场景

### 最佳实践
1.  **利用反向搜索**：当需要排除包含特定错误码或无关信息的日志时，使用“反向搜索”功能可以快速过滤掉噪音，专注于关键信息。
2.  **结合日志级别过滤**：在进行关键词搜索前，先通过日志级别过滤器（如只显示 ERROR 级别）缩小搜索范围，可以显著提高搜索效率和结果的相关性。
3.  **使用高级搜索**：对于复杂场景，可以使用“高级搜索”功能，组合关键词、时间范围和日志级别进行多条件筛选。

### 常见使用场景
1.  **定位特定错误**：当系统抛出一个已知的错误码（如 `ERR_CONNECTION_TIMEOUT`）时，可以直接在搜索框中输入该错误码，快速定位所有相关日志。
2.  **追踪用户行为**：通过搜索用户的唯一标识（如用户ID、会话ID），可以追踪该用户在系统中的完整操作流程。
3.  **分析性能瓶颈**：搜索特定的耗时操作日志（如 `query took 500ms`），并结合时间线功能，可以分析系统在特定时间段的性能表现。
4.  **审计与合规**：搜索特定的敏感操作日志（如 `user deleted account`），用于安全审计和合规性检查。